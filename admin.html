<!DOCTYPE html>
<html lang="en">

<head>
    <style>
        @import url("https://emwiki.com/css/fonts.css");
    </style>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
    <title>EMwiki - Admin Panel</title>
    <link rel="icon" href="./imgs/admin.png" />
    <link rel="preload" href="./css/admin.css" as="style" onload="this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="./css/admin.css">
    </noscript>

    <link rel="manifest" href="/dev.webmanifest">
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
</head>

<body data-theme="dark">
    <!-- Canvas for arrow overlay -->
    <canvas id="overlay" class="fixed inset-0 pointer-events-none"
        style="pointer-events:none;position:fixed;z-index:9999999;"></canvas>

    <!-- Login Overlay -->
    <div id="login-overlay">
        <div class="login-card">
            <div class="garagedoor">
                <div class="texture-overlay"></div>
                <div class="endofdoor"></div>
            </div>
            <img src="./imgs/eng.png">
            <div id="welcome-label"></div>
            <h2>Admin Panel</h2>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">Login with your Roblox account to access admin
                features</p>
            <div id="auth-container"></div>
            <div id="login-error"></div>
        </div>
    </div>

    <svg style="position:absolute;width:0;height:0">
        <filter id="frosted" primitiveUnits="objectBoundingBox">
            <feImage href="/imgs/bubble.png" x="0" y="0" width="1" height="1" result="map" />
            <feGaussianBlur in="SourceGraphic" stdDeviation="0.02" result="blur" />
            <feDisplacementMap id="disp" in="blur" in2="map" scale="1" xChannelSelector="R" yChannelSelector="G">
                <animate attributeName="scale" to="1.4" dur="0.3s" begin="btn.mouseover" fill="freeze" />
                <animate attributeName="scale" to="1" dur="0.3s" begin="btn.mouseout" fill="freeze" />
            </feDisplacementMap>
        </filter>
    </svg>

    <!-- Header -->
    <header>
        <h1><img src="./imgs/eng.png" style="width: 52px;">
            <a href="https://emwiki.com">EMwiki
                <strong style="font-variant-caps: all-petite-caps;line-height: 0.85;color: #5c6c7a;font-size: 16px;white-space: nowrap;">Admin Panel</strong>
            </a>
            <div id="undo-redo-controls" style="margin-left: 20px;display: flex; gap: 8px;">
                <button id="undo-btn" class="small-btn ghost" style="padding: 8px;" disabled title="Undo (Ctrl+Z)">
                    <span class="icon undo-icon" style="margin:0;width: 20px;height: 20px;"></span>
                </button>
                <button id="redo-btn" class="small-btn ghost" style="padding: 8px;" disabled title="Redo (Ctrl+Y)">
                    <span class="icon redo-icon" style="margin:0;width: 20px;height: 20px;"></span>
                </button>
            </div>
        </h1>

        <div id="top-controls">
            <div class="tag" id="admin-online" style="display:flex;flex-direction:row-reverse;gap:4px;">connecting...
            </div>

            <div id="panels-btn" title="Manage Panels"><svg width="18px" viewBox="0 0 21 21"
                    xmlns="http://www.w3.org/2000/svg">
                    <g fill="none" fill-rule="evenodd" stroke="var(--muted)" stroke-linecap="round"
                        stroke-linejoin="round" transform="translate(3 3)">
                        <path
                            d="m14.4978951 12.4978973-.0105089-9.99999996c-.0011648-1.10374784-.8962548-1.99789734-2-1.99789734h-9.99999995c-1.0543629 0-1.91816623.81587779-1.99451537 1.85073766l-.00548463.151365.0105133 10.00000004c.0011604 1.1037478.89625045 1.9978973 1.99999889 1.9978973h9.99999776c1.0543618 0 1.9181652-.8158778 1.9945143-1.8507377z" />
                        <path d="m7.5.5v13.817" />
                        <path d="m14.5 7.5h-14" />
                    </g>
                </svg></div>
            <div id="settings-btn">âš™</div>
        </div>
        <div class="menu" id="settings-menu">
            <h2>Settings</h2>
            <label>Theme
                <select id="theme-select">
                    <option value="dark">Dark</option>
                </select>
            </label>
            <label>Quick actions</label>

            <!-- Import/Export section -->
            <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <button id="import-json" class="small-btn ghost" style="flex: 1;">
                    <span class="icon upload-icon"></span>
                    Import JSON
                </button>
                <button id="download-json" class="small-btn ghost" style="flex: 1;">
                    <span class="icon download-icon"></span>
                    Export JSON
                </button>
            </div>

            <!-- Hidden file input for import -->
            <input type="file" id="json-file-input" accept=".json,application/json" style="display: none;">

            <button id="logout">
                <span class="icon logout-icon"></span>
                Logout
            </button>
            <div style="height:8px"></div>
            <div class="note">Tip: edits modify the loaded list in memory.<br>Click SAVE to publish to website.</div>
        </div>
        <div class="menu" id="panels-menu">
            <h2>Panels</h2>
            <div id="panels-list"></div>
            <div class="note" style="margin-top:12px">Click to show/hide panels</div>
        </div>
    </header>

    <!-- Main Content -->
    <main style="display: none;">

        <div id="main-content">
            <div id="quick-editor-spacer" style="visibility: hidden;width: 424px;" class="initial"></div>
            <div class="section" id="lists-section">
                <h2>Shops</h2>
                <div id="shops-container"></div>
                <div class="panel" style="margin-top:8px">
                    <div id="filter-controls" class="flex" style="margin-bottom:22px"></div>
                    <div id="all-items" class="grid"></div>
                    <div id="pagination-controls"></div>
                </div>
            </div>

            <!-- History Section -->
            <div class="section" id="history-section">
                <h2>History</h2>
                <div id="history-list">
                    <div class="torn-edge"></div>
                </div>

            </div>

            <!-- Notes Section -->
            <div class="section" id="notes-section">
                <h2>Notes</h2>
                <div class="board-container">
                    <div class="notes-area" id="notesArea"></div>
                    <div class="plusPad">
                        <button class="add-button" id="addButton">+</button>
                    </div>
                    <div class="input-form" id="inputForm">
                        <input type="text" class="note-input" id="noteInput" placeholder="Type your note..."
                            maxlength="200">
                        <button class="send-btn" id="sendNoteBtn">
                            <span class="icon send-icon"></span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Gallery Moderation Section -->
            <div class="section" id="gallery-moderation-section">
                <h2>Gallery Moderation</h2>
                <div class="panel" id="pending-gallery-items">
                    <p class="loading">Loading pending submissions...</p>
                </div>
            </div>

            <!-- Demand Needs Review Section -->
            <div class="section" id="demand-review-section">
                <h2>Demand Ratings - Needs Review</h2>
                <div class="panel">
                    <div style="margin-bottom: 20px;">


                        <!-- Search/Filter -->
                        <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                            <input
                                type="text"
                                id="demand-search-input"
                                placeholder="Search items by name..."
                                style="flex: 1; padding: 10px; border: 1px solid #6363637d; border-radius: 6px; background: #63636347; color: white;">
                            <select
                                id="demand-category-filter"
                                style="padding: 10px; border: 1px solid #6363637d; border-radius: 6px; background: #63636347; color: white; cursor: pointer;">
                                <option value="all">All Categories</option>
                                <option value="gears">Gears</option>
                                <option value="deaths">Deaths</option>
                                <option value="pets">Pets</option>
                                <option value="effects">Effects</option>
                                <option value="titles">Titles</option>
                            </select>
                        </div>

                        <!-- Review Filters -->
                        <div style="background: #2a2a2a; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                            <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                                <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #999;">
                                    <input type="checkbox" id="show-no-rating" checked style="cursor: pointer;">
                                    No Rating (0)
                                </label>
                                <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #999;">
                                    <input type="checkbox" id="show-old-rating" checked style="cursor: pointer;">
                                    Old Ratings (30+ days)
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Items Grid -->
                    <div id="demand-items-grid" style="
                        display: grid;
                        gap: 12px;
                        max-height: 600px;
                        overflow-y: auto;
                        padding: 8px;
                    ">
                        <p class="loading">Loading items...</p>
                    </div>

                    <!-- Pagination -->
                    <div id="demand-pagination" style="
                        margin-top: 16px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        gap: 12px;
                    ">
                        <button id="demand-prev-btn" class="small-btn ghost" disabled>Previous</button>
                        <span id="demand-page-info" style="color: var(--text-secondary); font-size: 14px;">Page 1</span>
                        <button id="demand-next-btn" class="small-btn ghost">Next</button>
                    </div>

                    <!-- Info -->
                    <div style="margin-top: 20px; padding-top: 5px; border-top: 1px solid #6363637d;">
                        <p style="color: gray; font-size: 13px; font-style: italic;">
                            ðŸ’¡ Tip: Items that haven't had their demand updated recently. Review and update ratings as needed using the Quick Editor.
                        </p>
                    </div>
                </div>
            </div>

            <!-- User Management Section -->
            <div class="section" id="user-management-section">
                <h2>User Management</h2>
                <div class="panel">
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">Search User</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="user-search-input" placeholder="Enter Roblox username or user ID"
                                style="flex: 1; padding: 10px; border: 1px solid #6363637d; border-radius: 6px; background: #63636347; color: white;">
                            <button id="user-search-btn" class="small-btn" style="padding: 10px 20px;">Search</button>
                        </div>
                    </div>
                    <div id="user-management-results" style="
                    display: inline-flex;
                    flex-direction: row;
                    gap: 11px;
                    flex-wrap: wrap;
                    justify-content: space-evenly;"></div>
                </div>
            </div>

            <div class="section" id="publish-section">
                <h2>Publish Changes</h2>
                <div class="publish-panel">
                    <button id="publish-btn" class="rocket-btn">
                        <span class="rocket-icon"></span>
                        <span class="publish-label">Publish</span>
                    </button>
                    <div id="publish-status" class="publish-status"></div>
                    <div class="publish-art">
                        <!-- Rocket trail and stars for artistic touch -->
                        <div class="rocket-trail"></div>
                        <div class="rocket-stars"></div>
                    </div>
                </div>
                <div class="note" style="margin-top:12px">
                    When you're ready, hit <b>Publish</b> to publish your changes to the website.
                </div>
            </div>
        </div>

    </main>

    <!-- Quick Editor Modal -->
    <div id="quick-editor-modal" class="hidden">
        <div id="quick-editor-content" class="initial">
            <div id='tutorial'>
                <h1>Quick Editor</h1>
                <p style="color: #f0f8ff;">Double Click an item to start editing.</p>
                <p style="color: #f0f8ffc9;">Drag the panel to move it around.</p>
                <p style="color: #f0f8ff8f;">Use the "Save" button to apply changes.</p>
                <p style="color: #f0f8ff6e;">Click the "Close" button to hide.</p>
            </div>
            <button id="quick-editor-close" title="Close">&times;</button>
            <h2 id="quick-editor-title"></h2>
            <img id="quick-editor-img" src="" alt="" />
            <div class="quick-editor-body">
                <div class="price-tag">
                    <input id="quick-editor-price" autocomplete="off" type="text" placeholder="RAP" />
                </div>
                <div class="flag-row"></div>

                <!-- Demand Rating -->
                <div class="demand-rating-section" style="margin-top: 12px;">
                    <label style="font-size: 13px; color: #999;padding-left: 0px; margin-bottom: 6px; display: block;">Demand Rating</label>
                    <div id="quick-editor-demand-buttons" style="display: flex; gap: 6px;">
                        <button class="demand-rating-btn" data-demand="0" title="Terrible">0</button>
                        <button class="demand-rating-btn" data-demand="1" title="Bad">1</button>
                        <button class="demand-rating-btn" data-demand="2" title="Okay">2</button>
                        <button class="demand-rating-btn" data-demand="3" title="Good">3</button>
                        <button class="demand-rating-btn" data-demand="4" title="Great">4</button>
                        <button class="demand-rating-btn" data-demand="5" title="Amazing">5</button>
                    </div>
                    <small id="demand-label" style="color: #666; font-size: 11px; margin-top: 4px; display: block;"></small>
                </div>
            </div>
            <hr>
            <div id="quick-editor-lists">


                <div>
                    <label>Descriptionsâ†´</label>
                    <ul class="desc-list"></ul>
                    <button id="new-desc-btn">Text</button>
                    <button id="new-gn-btn">Gamenight Date</button>
                </div>

                <div style="margin-top:9px;">
                    <label>
                        Code / Rarity / Priceâ†´
                        <h1>?</h1>
                        <p>Coins, Stars, %, Opals, Baubles, Tokens, Eggs, Pumpkins, Visors, Robux, Unobtainable</p>
                    </label>
                    <ul class="prc-list"></ul>
                    <button style="padding-bottom:8px;margin-bottom:0px;" id="new-prc-btn">Code / Rarity /
                        Price</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Save Button -->


    <script>

        function print(msg) {
            console.log(`[Admin Panel] ${msg}`);
        }
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        // ============================
        // Configuration & Constants
        // ============================
        const CONFIG = {
            WS_URLS: {
                ADMIN_TRACKER: 'wss://admin-tracker.xnite7.workers.dev',
                NOTES_BOARD: 'wss://notes-board.xnite7.workers.dev'
            },
            API_URLS: {
                LATEST_VERSION: 'https://emwiki.com/api/latest-version',
                GIST_VERSION: 'https://emwiki.com/api/gist-version',
                UPDATE_GIST: 'https://emwiki.com/api/update-gist',
                HISTORY: 'https://emwiki.com/api/history'
            },
            UI: {
                SNAP_MARGIN: 12,
                WIDTH_THRESHOLD: 1300,
                RECENT_ADMIN_DURATION: 5000,
                ITEM_MIN_WIDTH: 132,
                GRID_GAP: 12
            },
            ICONS: {
                download: 'data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3Csvg%20viewBox%3D%220%200%2024%2024%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M12%202a1%201%200%200%201%201%201v10.586l2.293-2.293a1%201%200%200%201%201.414%201.414l-4%204a1%201%200%200%201-1.414%200l-4-4a1%201%200%201%201%201.414-1.414L11%2013.586V3a1%201%200%200%201%201-1zM5%2017a1%201%200%200%201%201%201v2h12v-2a1%201%200%201%201%202%200v2a2%202%200%200%201-2%202H6a2%202%200%200%201-2-2v-2a1%201%200%200%201%201-1z%22%2F%3E%3C%2Fsvg%3E',
                logout: 'data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3Csvg%20viewBox%3D%220%200%2024%2024%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M2%206a2%202%200%200%201%202-2h9a2%202%200%200%201%202%202v2a1%201%200%201%201-2%200V6H4v12h9v-2a1%201%200%201%201%202%200v2a2%202%200%200%201-2%202H4a2%202%200%200%201-2-2V6zm15.293%202.293a1%201%200%200%201%201.414%200l3%203a1%201%200%200%201%200%201.414l-3%203a1%201%200%200%201-1.414-1.414L18.586%2013H9a1%201%200%201%201%200-2h9.586l-1.293-1.293a1%201%200%200%201%200-1.414z%22%2F%3E%3C%2Fsvg%3E',
                send: 'data:image/svg+xml,%3Csvg%20viewBox%3D%220%200%2024%2024%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M12%202a1%201%200%200%201%20.894.553l9%2018a1%201%200%200%201-1.11%201.423L12%2020.024l-8.783%201.952a1%201%200%200%201-1.111-1.423l9-18A1%201%200%200%201%2012%202zm1%2016.198l6.166%201.37L13%207.236v10.962zM11%207.236L4.834%2019.568%2011%2018.198V7.236z%22%2F%3E%3C%2Fsvg%3E',
                edit: 'data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3Csvg%20viewBox%3D%220%200%2024%2024%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M16.293%203.293a1%201%200%200%201%201.414%200l3%203a1%201%200%200%201%200%201.414l-9%209A1%201%200%200%201%2011%2017H8a1%201%200%200%201-1-1v-3a1%201%200%200%201%20.293-.707l9-9zM9%2013.414V15h1.586l8-8L17%205.414l-8%208zM3%207a2%202%200%200%201%202-2h5a1%201%200%201%201%200%202H5v12h12v-5a1%201%200%201%201%202%200v5a2%202%200%200%201-2%202H5a2%202%200%200%201-2-2V7z%22%20%2F%3E%3C%2Fsvg%3E',
                delete: 'data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3Csvg%20viewBox%3D%220%200%2024%2024%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M7%204a2%202%200%200%201%202-2h6a2%202%200%200%201%202%202v2h4a1%201%200%201%201%200%202h-1.069l-.867%2012.142A2%202%200%200%201%2017.069%2022H6.93a2%202%200%200%201-1.995-1.858L4.07%208H3a1%201%200%200%201%200-2h4V4zm2%202h6V4H9v2zM6.074%208l.857%2012H17.07l.857-12H6.074zM10%2010a1%201%200%200%201%201%201v6a1%201%200%201%201-2%200v-6a1%201%200%200%201%201-1zm4%200a1%201%200%200%201%201%201v6a1%201%200%201%201-2%200v-6a1%201%200%200%201%201-1z%22%20%2F%3E%3C%2Fsvg%3E',
                check: 'data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3Csvg%20viewBox%3D%220%20-8%2072%2072%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M61.07%2C12.9%2C57%2C8.84a2.93%2C2.93%2C0%2C0%2C0-4.21%2C0L28.91%2C32.73%2C19.2%2C23A3%2C3%2C0%2C0%2C0%2C15%2C23l-4.06%2C4.07a2.93%2C2.93%2C0%2C0%2C0%2C0%2C4.21L26.81%2C47.16a2.84%2C2.84%2C0%2C0%2C0%2C2.1.89A2.87%2C2.87%2C0%2C0%2C0%2C31%2C47.16l30.05-30a2.93%2C2.93%2C0%2C0%2C0%2C0-4.21Z%22%2F%3E%3C%2Fsvg%3E',
                gamenight: 'data:image/svg+xml,%3Csvg%20viewBox%3D%220%200%2024%2024%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20class%3D%22icon%20flat-color%22%3E%3Cpath%20id%3D%22primary%22%20d%3D%22M22%2C9.81a1%2C1%2C0%2C0%2C0-.83-.69l-5.7-.78L12.88%2C3.53a1%2C1%2C0%2C0%2C0-1.76%2C0L8.57%2C8.34l-5.7.78a1%2C1%2C0%2C0%2C0-.82.69%2C1%2C1%2C0%2C0%2C0%2C.28%2C1l4.09%2C3.73-1%2C5.24A1%2C1%2C0%2C0%2C0%2C6.88%2C20.9L12%2C18.38l5.12%2C2.52a1%2C1%2C0%2C0%2C0%2C.44.1%2C1%2C1%2C0%2C0%2C0%2C1-1.18l-1-5.24%2C4.09-3.73A1%2C1%2C0%2C0%2C0%2C22%2C9.81Z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E',
                prices: 'data:image/svg+xml,%3Csvg%20viewBox%3D%220%200%2024%2024%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M20%2C2H14a1%2C1%2C0%2C0%2C0-.71.29L3%2C12.55a2%2C2%2C0%2C0%2C0%2C0%2C2.83L8.62%2C21a2%2C2%2C0%2C0%2C0%2C1.41.59h0A2%2C2%2C0%2C0%2C0%2C11.45%2C21L21.71%2C10.7A1%2C1%2C0%2C0%2C0%2C22%2C10V4A2%2C2%2C0%2C0%2C0%2C20%2C2Z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E',
                newest: 'data:image/svg+xml,%3Csvg%20viewBox%3D%2215%2015%2046%2046%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22m44.483%2015.815-6.458%2017.179h-.223l-6.125-17.18-9.91%205.764%2011.692%2014.076v.221L16.087%2032.33v11.194L33.57%2040.42l.111.221-11.915%2013.855%209.577%205.652L37.69%2043.08h.223l6.459%2017.068%209.8-5.653-12.027-13.743v-.221l17.926%202.992V32.329l-17.815%203.547v-.222l11.915-14.187z%22%2F%3E%3C%2Fsvg%3E',
                upload: 'data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3Csvg%20viewBox%3D%220%200%2024%2024%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M12%2022a1%201%200%200%201-1-1V10.414L8.707%2012.707a1%201%200%200%201-1.414-1.414l4-4a1%201%200%200%201%201.414%200l4%204a1%201%200%201%201-1.414%201.414L13%2010.414V21a1%201%200%200%201-1%201zM5%207a1%201%200%200%201-1-1V4a2%202%200%200%201%202-2h12a2%202%200%200%201%202%202v2a1%201%200%201%201-2%200V4H6v2a1%201%200%200%201-1%201z%22%2F%3E%3C%2Fsvg%3E'
            }
        };

        // ============================
        // Development Mode Configuration
        // ============================

        const DEV_MODE = {

            enabled: window.location.hostname === 'localhost' ||
                window.location.origin === 'file://' ||
                window.location.hostname.includes('.local'),
            adminName: 'dev_admin',
            mockData: {
                jsData: {
                    "weapons": [],
                    "backs": [],
                    "heads": [],
                    // Add sample data as needed
                }
            }
        };

        // ============================
        // State Management
        // ============================
        class AppState {
            constructor() {
                this.jsData = {};
                this.allItems = [];
                this.filteredItems = [];
                this.currentPage = 1;
                this.resizeTimer = 0;
                this.itemsPerPage = 0;
                this.currentEditingItem = null;
                this.adminName = '';
                this.currentVersion = 0;
                this.gistVersion = 0;
                this.notes = [];
                this.recentAdmins = new Map();

                this.originalItems = new Map(); // Store original states
                this.changedItems = new Set(); // Track which items have changes

                this.filters = {
                    search: '',
                    category: 'all',
                    gamenightOnly: false,
                    sort: 'default',
                    showPrices: false,
                    newestOnly: false
                };
                this.ws = {
                    admin: null,
                    notes: null
                };
            }
        }

        const state = new AppState();

        // ============================
        // Change Tracking
        // ============================

        const ChangeTracker = {
            // Track different types of items
            originalItems: new Map(),      // Original state of items that existed at load
            newItems: new Set(),           // Items added during this session
            modifiedItems: new Set(),      // Items that have been modified
            deletedItems: new Map(),       // Items that were deleted (name -> original state)

            // Initialize with the original data
            initializeOriginals() {
                // Clear everything first
                this.originalItems.clear();
                this.newItems.clear();
                this.modifiedItems.clear();
                this.deletedItems.clear();

                // Capture all existing items as originals
                state.allItems.forEach(item => {
                    this.originalItems.set(item.name, JSON.stringify(item));
                });
            },

            // Check if an item is new (added this session)
            isNewItem(itemName) {
                return this.newItems.has(itemName);
            },

            // Check if an item is modified from its original state
            isModifiedItem(itemName) {
                // New items can't be "modified" in the traditional sense
                if (this.isNewItem(itemName)) return false;
                return this.modifiedItems.has(itemName);
            },

            // Check if an item has any changes (new or modified)
            hasChanges(itemName) {
                return this.isNewItem(itemName) || this.isModifiedItem(itemName);
            },

            // Mark an item as new
            markAsNew(itemName) {
                this.newItems.add(itemName);
                // New items aren't modified
                this.modifiedItems.delete(itemName);
            },

            // Mark an item as deleted
            markAsDeleted(itemName, originalState) {
                this.deletedItems.set(itemName, originalState);
                this.newItems.delete(itemName);
                this.modifiedItems.delete(itemName);
            },

            // Restore a deleted item
            restoreDeleted(itemName) {
                const originalState = this.deletedItems.get(itemName);
                if (originalState) {
                    this.deletedItems.delete(itemName);
                    // Check if it was originally a new item or existing
                    if (!this.originalItems.has(itemName)) {
                        this.newItems.add(itemName);
                    }
                }
            },

            // Check for modifications on an existing item
            checkModifications(item, oldName = null) {
                const itemName = oldName || item.name;

                if (this.isNewItem(itemName)) {
                    // If name changed on a new item, update tracking
                    if (oldName && oldName !== item.name) {
                        this.newItems.delete(oldName);
                        this.newItems.add(item.name);
                    }
                    return;
                }

                // Check against original for existing items
                const originalJson = this.originalItems.get(itemName);
                if (!originalJson) {
                    console.warn(`No original found for ${itemName}`);
                    return;
                }

                const original = JSON.parse(originalJson);
                const hasChanges = this.compareItems(original, item);

                if (hasChanges) {
                    this.modifiedItems.add(item.name);
                    // If name changed, also clean up old name from modified items
                    if (oldName && oldName !== item.name) {
                        this.modifiedItems.delete(oldName);
                        // Update the original items map with new name
                        this.originalItems.delete(oldName);
                        this.originalItems.set(item.name, originalJson);
                    }
                } else {
                    this.modifiedItems.delete(item.name);
                    if (oldName && oldName !== item.name) {
                        this.modifiedItems.delete(oldName);
                    }
                }
            },

            // Compare two items for changes
            compareItems(original, current) {
                // Normalize price values for comparison
                const normalizePrice = (price) => {
                    if (!price || price === '' || price === 'N/A' || price === 'undefined') {
                        return '0';
                    }
                    return String(price);
                };

                // List of fields to check
                const fields = ['name', 'img', 'svg', 'price', 'from', 'price/code/rarity',
                    'weekly', 'weeklystar', 'new', 'retired', 'premium', 'tradable', 'removed', 'demand'];

                // Check each field for changes
                for (const field of fields) {
                    let val1 = original[field];
                    let val2 = current[field];

                    // Normalize price field
                    if (field === 'price') {
                        val1 = normalizePrice(val1);
                        val2 = normalizePrice(val2);
                    }

                    // Convert undefined/null to empty string for comparison
                    if (val1 === undefined || val1 === null) val1 = '';
                    if (val2 === undefined || val2 === null) val2 = '';

                    // Compare values
                    if (String(val1) !== String(val2)) {
                        return true; // Has changes
                    }
                }

                return false; // No changes
            },

            // Update visual indicators
            updateHighlights() {
                document.querySelectorAll('.item-card').forEach(card => {
                    const name = card.dataset.name;

                    // Remove all change classes first
                    card.classList.remove('changed', 'new-item', 'modified-item');

                    if (this.isNewItem(name)) {
                        card.classList.add('changed', 'new-item');
                    } else if (this.isModifiedItem(name)) {
                        card.classList.add('changed', 'modified-item');
                    }
                });
            },

            // Get all changes for publishing
            getAllChanges() {
                return {
                    newItems: Array.from(this.newItems),
                    modifiedItems: Array.from(this.modifiedItems),
                    deletedItems: Array.from(this.deletedItems.keys()),
                    hasChanges: this.newItems.size > 0 ||
                        this.modifiedItems.size > 0 ||
                        this.deletedItems.size > 0
                };
            },

            // Check if a value existed in the original item (for desc/price items)
            isValueOriginal(item, field, value) {
                // New items don't have "original" values
                if (this.isNewItem(item.name)) return false;

                const originalJson = this.originalItems.get(item.name);
                if (!originalJson) return false;

                const originalData = JSON.parse(originalJson);
                const originalFieldValue = originalData[field] || '';
                const originalLines = originalFieldValue.split('<br>')
                    .map(line => line.trim())
                    .filter(Boolean);

                return originalLines.includes(value.trim());
            }
        };

        // Fixed UndoRedoManager
        const UndoRedoManager = {
            history: [],
            currentIndex: -1,
            maxHistorySize: 50,
            isApplyingChange: false,

            // Clear and initialize
            init() {
                console.log('Initializing UndoRedoManager');
                this.clear();
                this.setupEventListeners();
                this.updateButtons();
            },

            clear() {
                this.history = [];
                this.currentIndex = -1;
                this.updateButtons();
            },

            // Record a change action
            recordChange(action) {
                if (this.isApplyingChange) return;

                // Remove any history after current index
                this.history = this.history.slice(0, this.currentIndex + 1);

                // Create a complete snapshot of the action
                const snapshot = {
                    timestamp: Date.now(),
                    type: action.type,
                    itemName: action.itemName,
                    category: action.category,
                    data: JSON.parse(JSON.stringify(action.data || {})),
                    previousState: action.previousState ? JSON.parse(JSON.stringify(action.previousState)) : null,
                    newState: action.newState ? JSON.parse(JSON.stringify(action.newState)) : null,
                    wasNewItem: ChangeTracker.isNewItem(action.itemName)
                };

                this.history.push(snapshot);

                // Limit history size
                if (this.history.length > this.maxHistorySize) {
                    this.history.shift();
                } else {
                    this.currentIndex++;
                }

                this.updateButtons();
            },

            // Find an item in the current data
            findItem(itemName) {
                for (const [category, items] of Object.entries(state.jsData)) {
                    if (Array.isArray(items)) {
                        const item = items.find(i => i.name === itemName);
                        if (item) return { item, category, index: items.indexOf(item) };
                    }
                }
                return null;
            },

            // Undo the last action
            undo() {
                if (!this.canUndo()) return;

                this.isApplyingChange = true;
                const action = this.history[this.currentIndex];

                switch (action.type) {
                    case 'add':
                        this.undoAdd(action);
                        break;
                    case 'edit':
                        this.undoEdit(action);
                        break;
                    case 'delete':
                        this.undoDelete(action);
                        break;
                }

                this.currentIndex--;
                this.isApplyingChange = false;

                // Update UI
                UI.renderItems(true);
                UI.renderShops();
                ChangeTracker.updateHighlights();
                this.updateButtons();

                // Refresh Quick Editor if open
                if (state.currentEditingItem && state.currentEditingItem.name === action.itemName) {
                    const result = this.findItem(action.itemName);
                    if (result) {
                        QuickEditor.open(result.item);
                    } else {
                        QuickEditor.close();
                    }
                }
            },

            // Redo the next action
            redo() {
                if (!this.canRedo()) return;

                this.isApplyingChange = true;
                this.currentIndex++;
                const action = this.history[this.currentIndex];

                switch (action.type) {
                    case 'add':
                        this.redoAdd(action);
                        break;
                    case 'edit':
                        this.redoEdit(action);
                        break;
                    case 'delete':
                        this.redoDelete(action);
                        break;
                }

                this.isApplyingChange = false;

                // Update UI
                UI.renderItems(true);
                UI.renderShops();
                ChangeTracker.updateHighlights();
                this.updateButtons();

                // Refresh Quick Editor if open
                if (state.currentEditingItem && state.currentEditingItem.name === action.itemName) {
                    const result = this.findItem(action.itemName);
                    if (result) {
                        QuickEditor.open(result.item);
                    }
                }
            },

            // Undo handlers
            undoAdd(action) {
                const result = this.findItem(action.itemName);
                if (!result) return;

                // Remove the item
                state.jsData[result.category].splice(result.index, 1);
                state.allItems = Object.values(state.jsData).flat();

                // Update tracking
                ChangeTracker.newItems.delete(action.itemName);
                ChangeTracker.markAsDeleted(action.itemName, action.newState);

                ErrorHandler.showToast(`â®Œ Removed: ${action.itemName}`, 'info');
            },

            undoEdit(action) {
                if (!action.previousState) return;

                const result = this.findItem(action.itemName);
                if (!result) return;

                // Restore previous state
                Object.assign(result.item, action.previousState);

                // Update tracking - check if it should still be marked as modified
                if (!action.wasNewItem) {
                    ChangeTracker.checkModifications(result.item);
                }

                ErrorHandler.showToast(`â®Œ Restored: ${action.itemName}`, 'info');
            },

            undoDelete(action) {
                if (!action.previousState) return;

                // Re-add the item
                const category = action.category;
                if (!state.jsData[category]) {
                    state.jsData[category] = [];
                }

                // Find correct position
                const categoryItems = state.jsData[category];
                let insertIndex = categoryItems.findIndex(item =>
                    item.name.toLowerCase() > action.previousState.name.toLowerCase()
                );

                if (insertIndex === -1) {
                    insertIndex = categoryItems.length;
                }

                categoryItems.splice(insertIndex, 0, action.previousState);
                state.allItems = Object.values(state.jsData).flat();

                // Restore tracking state
                ChangeTracker.restoreDeleted(action.itemName);

                ErrorHandler.showToast(`â®Œ Restored: ${action.itemName}`, 'info');
            },

            // Redo handlers
            redoAdd(action) {
                if (!action.newState) return;

                const category = action.category;
                if (!state.jsData[category]) {
                    state.jsData[category] = [];
                }

                // Find correct position
                const categoryItems = state.jsData[category];
                let insertIndex = categoryItems.findIndex(item =>
                    item.name.toLowerCase() > action.newState.name.toLowerCase()
                );

                if (insertIndex === -1) {
                    insertIndex = categoryItems.length;
                }

                categoryItems.splice(insertIndex, 0, action.newState);
                state.allItems = Object.values(state.jsData).flat();

                // Mark as new
                ChangeTracker.markAsNew(action.itemName);
                ChangeTracker.deletedItems.delete(action.itemName);

                ErrorHandler.showToast(`â®Ž Re-added: ${action.itemName}`, 'info');
            },

            redoEdit(action) {
                if (!action.newState) return;

                const result = this.findItem(action.itemName);
                if (!result) return;

                // Apply new state
                Object.assign(result.item, action.newState);

                // Update tracking
                if (!action.wasNewItem) {
                    ChangeTracker.checkModifications(result.item);
                }

                ErrorHandler.showToast(`â®Ž Re-applied: ${action.itemName}`, 'info');
            },

            redoDelete(action) {
                const result = this.findItem(action.itemName);
                if (!result) return;

                // Remove the item
                state.jsData[result.category].splice(result.index, 1);
                state.allItems = Object.values(state.jsData).flat();

                // Mark as deleted
                ChangeTracker.markAsDeleted(action.itemName, action.previousState);

                ErrorHandler.showToast(`â®Ž Re-deleted: ${action.itemName}`, 'info');
            },

            // UI helpers
            canUndo() {
                return this.currentIndex >= 0;
            },

            canRedo() {
                return this.currentIndex < this.history.length - 1;
            },

            updateButtons() {
                const undoBtn = DOM.get('undo-btn');
                const redoBtn = DOM.get('redo-btn');

                if (undoBtn) {
                    undoBtn.disabled = !this.canUndo();
                    undoBtn.style.opacity = this.canUndo() ? '1' : '0.3';

                    if (this.canUndo()) {
                        const lastAction = this.history[this.currentIndex];
                        undoBtn.title = `Undo: ${this.getActionDescription(lastAction)} (Ctrl+Z)`;
                    } else {
                        undoBtn.title = 'Undo (Ctrl+Z)';
                    }
                }

                if (redoBtn) {
                    redoBtn.disabled = !this.canRedo();
                    redoBtn.style.opacity = this.canRedo() ? '1' : '0.3';

                    if (this.canRedo()) {
                        const nextAction = this.history[this.currentIndex + 1];
                        redoBtn.title = `Redo: ${this.getActionDescription(nextAction)} (Ctrl+Y)`;
                    } else {
                        redoBtn.title = 'Redo (Ctrl+Y)';
                    }
                }
            },

            getActionDescription(action) {
                switch (action.type) {
                    case 'add':
                        return `Add ${action.itemName}`;
                    case 'delete':
                        return `Delete ${action.itemName}`;
                    case 'edit':
                        if (action.previousState && action.newState) {
                            const changes = [];
                            if (action.previousState.price !== action.newState.price) changes.push('price');
                            if (action.previousState.from !== action.newState.from) changes.push('description');
                            if (action.previousState['price/code/rarity'] !== action.newState['price/code/rarity']) changes.push('codes');
                            if (action.previousState.demand !== action.newState.demand) {
                                const labels = ['Terrible', 'Bad', 'Okay', 'Good', 'Great', 'Amazing'];
                                const oldLabel = labels[action.previousState.demand || 0];
                                const newLabel = labels[action.newState.demand || 0];
                                changes.push(`demand (${oldLabel}â†’${newLabel})`);
                            }

                            const flags = ['weekly', 'weeklystar', 'new', 'retired', 'premium', 'tradable'];
                            flags.forEach(flag => {
                                if (action.previousState[flag] !== action.newState[flag]) {
                                    changes.push(flag);
                                }
                            });

                            return `Edit ${action.itemName}${changes.length ? ': ' + changes.join(', ') : ''}`;
                        }
                        return `Edit ${action.itemName}`;
                    default:
                        return 'Unknown action';
                }
            },

            setupEventListeners() {
                // Button click handlers
                const undoBtn = DOM.get('undo-btn');
                const redoBtn = DOM.get('redo-btn');

                if (undoBtn) {
                    undoBtn.addEventListener('click', () => this.undo());
                }

                if (redoBtn) {
                    redoBtn.addEventListener('click', () => this.redo());
                }

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Don't trigger when typing in inputs
                    if (e.target.tagName === 'INPUT' ||
                        e.target.tagName === 'TEXTAREA' ||
                        e.target.tagName === 'SELECT') {
                        return;
                    }

                    if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') {
                        e.preventDefault();
                        this.undo();
                    } else if ((e.ctrlKey || e.metaKey) &&
                        (e.shiftKey && e.key.toLowerCase() === 'z' || e.key.toLowerCase() === 'y')) {
                        e.preventDefault();
                        this.redo();
                    }
                });
            }
        };

        // ============================
        // Item Adder System
        // ============================

        const ItemAdder = {
            modal: null,
            currentStep: 1,
            newItemData: {},
            uploadedImageUrl: null,

            // SVG icons for categories
            CATEGORY_ICONS: {
                'gears': '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 3V4H9V5H10V6H11V7H12V8H13V9H14V10H15V11H16V12H17V11H19V13H18V14H17V15H18V16H19V17H20V19H19V20H17V19H16V18H15V17H14V18H13V19H11V17H12V16H11V15H10V14H9V13H8V12H7V11H6V10H5V9H4V8H3V7H2V2H7V3H8M7 5H6V4H4V5H5V6H6V7H7V8H8V9H9V10H10V11H11V12H12V13H14V12H13V11H12V10H11V9H10V8H9V7H8V6H7V5Z"/></svg>',
                'pets': '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M7 13H8V12H9V11H14V12H15V13H16V15H17V16H18V19H17V20H16V21H13V20H12V19H11V20H10V21H7V20H6V19H5V16H6V15H7ZM6 10H7V12H6V13H5V14H4V13H3V12H2V7H3V6H5V8H7V9H8V10H10V9H11V4H10V2H7V3H6V8ZM17 10H16V12H17V13H18V14H19V13H20V12H21V8H20V7H18V8H17V3H16V2H13V4H12V9H13V10H15V9H16V8H17Z"/></svg>',
                'effects': '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M14 20H7V19H6V18H5V17H4V12H5V10H6V9H7V8H8V9H9V11H10V9H11V5H10V4H9V3H8V2H11V3H13V4H14V5H15V6H16V7H17V9H18V16H17V18H16V19H14M12 18V17H14V16H15V14H16V10H15V8H14V7H13V11H12V13H11V14H10V15H9V14H8V11H7V12H6V16H7V17H8V18Z"/></svg>',
                'titles': '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M4 2V9H5V7H6V5H7V4H10V18H9V19H8V20H15V19H14V18H13V4H16V5H17V7H18V9H19V2Z"/></svg>',
                'deaths': '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 2H8V1H14V2H16V3H17V4H18V5H19V7H20V14H19V16H18V20H17V21H5V20H4V16H3V14H2V8H3V5H4V4H5V3H6V2M15 5V4H13V3H9V4H7V5H6V6H5V9H4V13H5V15H6V19H8V17H10V19H12V17H14V19H16V15H17V13H18V8H17V6H16V5H15M7 8H10V11H7V8M12 11V8H15V11H12M10 13H12V15H10V13Z"/></svg>'
            },

            init() {
                this.createModal();
                this.addTriggerButton();
            },

            addTriggerButton() {
                const filterControls = DOM.get('filter-controls');
                if (!filterControls) return;

                const addItemBtn = Utils.createElement('button', {
                    id: 'add-item-btn',
                    className: 'small-btn',
                    innerHTML: '<span class="icon plus-icon"></span>Add Item',
                    onClick: () => this.openModal()
                });

                filterControls.appendChild(addItemBtn);
            },

            createModal() {
                if (this.modal) {
                    this.modal.remove();
                }

                this.modal = document.createElement('div');
                this.modal.id = 'item-adder-modal';
                this.modal.className = 'item-adder-overlay hidden';
                this.modal.innerHTML = `<div class=item-adder-container><div class=item-adder-header><h2>Add New Item</h2><button class=close-btn id=item-adder-close>Ã—</button></div><div class=item-adder-steps><div class="active step"data-step=1><span class=step-number>1</span> <span class=step-label>Category</span></div><div class=step data-step=2><span class=step-number>2</span> 
                    <span class=step-label>Details</span></div><div class=step data-step=3><span class=step-number>3</span> <span class=step-label>Properties</span></div></div><div class=item-adder-body><div class="active step-content"id=step-1><h3>Select Category</h3><div class=category-grid>${Object.keys(state.jsData).map(cat => ` <button class=category-option data-category=${cat}>
                        <span class=category-icon>${this.CATEGORY_ICONS[cat] || this.CATEGORY_ICONS['accessories']}</span> <span class=category-name>${cat.charAt(0).toUpperCase() + cat.slice(1)}</span> <span class=category-count>${state.jsData[cat].length} items</span></button> `).join('')}</div></div><div class=step-content id=step-2><h3>Item Details</h3><div class=form-group>
                            <label>Name<strong>*</strong></label> <input type="text" id=item-name placeholder="Enter item name..."autocomplete=off></div>
                            <div class="form-group" id="image-upload-group">
                                <label>Icon<strong>*</strong></label>
                                <div class=image-upload-section>
                                    <div class=image-preview id=image-preview>
                                        <img alt=Preview id=preview-img src="" style=display:none> 
                                        <span id=preview-placeholder>No image selected</span>
                                        <button class=remove-image-btn id=remove-image style=display:none>Ã—</button>
                                    </div>
                                    <div class=upload-tabs>
                                        <button class="active upload-tab" data-tab=upload>
                                            <svg fill=currentColor height=16 viewBox="0 0 24 24" width=16>
                                                <path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/>
                                            </svg> Upload File
                                        </button> 
                                        <button class=upload-tab data-tab=url>
                                            <svg fill=currentColor height=16 viewBox="0 0 24 24" width=16>
                                                <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
                                            </svg> Enter URL
                                        </button>
                                    </div>
                                    <div class="active upload-content" id=upload-content-upload>
                                        <div class=file-upload-area>
                                            <input id=item-file-upload type=file accept=image/* style=display:none>
                                            <div class=upload-dropzone id=upload-dropzone>
                                                <svg fill=currentColor height=48 viewBox="0 0 24 24" width=48 style=opacity:.3>
                                                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                                                </svg>
                                                <p>Click to select or drag & drop image here</p>
                                                <small>PNG, JPG, GIF up to 5MB</small>
                                            </div>
                                            <div class=upload-status id=upload-status style=display:none>
                                                <div class=upload-progress>
                                                    <div class=progress-bar id=upload-progress-bar></div>
                                                </div>
                                                <span id=upload-status-text>Uploading...</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class=upload-content id=upload-content-url>
                                        <input type="text" id=item-img placeholder="imgs/category/filename.png" autocomplete=off> 
                                        <small>Enter the image URL or path</small>
                                    </div>
                                </div>
                            </div>

                            <!-- NEW: SVG Input Group (hidden by default) -->
                            <div class="form-group" id="svg-input-group" style="display: none;">
                                <label>SVG Code<strong>*</strong></label>
                                <textarea id="item-svg-input" placeholder="<svg width=&quot;230&quot; height=&quot;100&quot;...>" 
                                    rows="6" style="background: #1f2937;">
                                </textarea>
                                <small>Paste your SVG code here</small>
                                
                                <!-- SVG Preview -->
                                <div style="margin-top: 12px; padding: 12px; background: #111827; border-radius: 4px; 
                                    min-height: 80px; display: flex; align-items: center; justify-content: center;">
                                    <div id="svg-input-preview">
                                        <span style="color: #666;">SVG preview will appear here</span>
                                    </div>
                                </div>
                            </div>
                        
                        <div class=form-group><label>RAP</label> <input type="text" id=item-price placeholder="Enter price e.g.(69)"autocomplete=off></div><div class=form-group><label>Description</label> <textarea id=item-from placeholder="Obtainment method/@author/season x/tip"rows=3>
                                    </textarea> <small>Separate multiple lines with Enter</small></div><div class=form-group><label>Price/Code/Rarity</label> <textarea id=item-rarity placeholder="Code, rarity, or shop price"rows=3></textarea> <small>Separate multiple lines with Enter</small></div></div><div class=step-content id=step-3><h3>Item Properties</h3><div class=properties-grid><label class=property-toggle>
                                    <input id=item-untradable type=checkbox checked> <span>Untradable</span></label> <label class=property-toggle><input id=item-new type=checkbox> <span>New</span></label> <label class=property-toggle><input id=item-weekly type=checkbox> <span>Weekly Shop</span></label> <label class=property-toggle><input id=item-weeklystar type=checkbox> <span>Star Shop</span></label> <label class=property-toggle>
                                        <input id=item-retired type=checkbox> <span>Retired</span></label> <label class=property-toggle><input id=item-premium type=checkbox> <span>Premium</span></label></div><div class=item-preview><h4>Preview</h4>
                                            <div class=preview-card id=item-preview-card></div></div></div></div><div class=item-adder-footer><button class="small-btn ghost"id=item-adder-back style=display:none>Back</button> 
                                                <button class=small-btn id=item-adder-next>Next</button> <button class="small-btn success"id=item-adder-add style=display:none>Add Item</button></div></div>`;

                document.body.appendChild(this.modal);
                this.attachEventListeners();

            },

            attachEventListeners() {
                // Close button
                document.getElementById('item-adder-close').addEventListener('click', () => this.closeModal());

                // Category selection
                document.querySelectorAll('.category-option').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.newItemData.category = btn.dataset.category;
                        this.newItemData.isTitle = btn.dataset.category === 'titles';

                        document.querySelectorAll('.category-option').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        document.getElementById('item-adder-next').disabled = false;
                    });
                });

                // Navigation buttons
                document.getElementById('item-adder-next').addEventListener('click', () => this.nextStep());
                document.getElementById('item-adder-back').addEventListener('click', () => this.prevStep());
                document.getElementById('item-adder-add').addEventListener('click', () => this.addItem());

                // Tab switching
                document.querySelectorAll('.upload-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const tabName = e.currentTarget.dataset.tab;
                        this.switchUploadTab(tabName);
                    });
                });

                // File upload handling
                const fileInput = document.getElementById('item-file-upload');
                const dropzone = document.getElementById('upload-dropzone');

                // Click to upload
                dropzone.addEventListener('click', () => fileInput.click());

                // File selection
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.handleFileUpload(file);
                    }
                });

                // Drag and drop
                dropzone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropzone.classList.add('dragover');
                });

                dropzone.addEventListener('dragleave', () => {
                    dropzone.classList.remove('dragover');
                });

                dropzone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropzone.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    if (file && file.type.startsWith('image/')) {
                        this.handleFileUpload(file);
                    }
                });

                // URL input
                const imgInput = document.getElementById('item-img');
                if (imgInput) {
                    imgInput.addEventListener('input', (e) => {
                        this.updateImagePreview(e.target.value);
                        this.uploadedImageUrl = e.target.value;
                    });
                }

                // Remove image button
                document.getElementById('remove-image').addEventListener('click', () => {
                    this.clearImage();
                });

                let out = null;
                // Close on overlay click
                this.modal.addEventListener('mousedown', (e) => {
                    out = e.target;
                });

                this.modal.addEventListener('mouseup', (e) => {
                    if (e.target === this.modal && e.target === out) {
                        out = null;
                        this.closeModal();
                    }

                    out = null;
                });
                document.getElementById('item-untradable').onchange = () => this.updatePreview();
                document.getElementById('item-new').onchange = () => this.updatePreview();
                document.getElementById('item-weekly').onchange = () => this.updatePreview();
                document.getElementById('item-weeklystar').onchange = () => this.updatePreview();
                document.getElementById('item-retired').onchange = () => this.updatePreview();
                document.getElementById('item-premium').onchange = () => this.updatePreview();
                // ESC key to close
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && !this.modal.classList.contains('hidden')) {
                        this.closeModal();
                    }
                });
            },

            toggleInputMode() {
                const isTitle = this.newItemData.isTitle;
                const imageGroup = document.getElementById('image-upload-group');
                const svgGroup = document.getElementById('svg-input-group');

                if (isTitle) {
                    // Show SVG input, hide image upload
                    imageGroup.style.display = 'none';
                    svgGroup.style.display = 'block';

                    // Setup SVG preview
                    const svgInput = document.getElementById('item-svg-input');
                    const svgPreview = document.getElementById('svg-input-preview');

                    svgInput.oninput = () => {
                        const svgCode = svgInput.value.trim();
                        if (svgCode && svgCode.startsWith('<svg')) {
                            svgPreview.innerHTML = svgCode;
                        } else {
                            svgPreview.innerHTML = '<span style="color: #666;">SVG preview will appear here</span>';
                        }
                    };

                    // Set default SVG template
                    if (!svgInput.value) {
                        const name = document.getElementById('item-name').value.trim() || 'Title';
                        svgInput.value = `<svg width="230" height="100" viewBox="457.90625 471 84.751953125 39" xmlns="http://www.w3.org/2000/svg"><text x="500" y="500" xmlns="http://www.w3.org/2000/svg" text-anchor="middle" stroke="#545454" stroke-width="3" paint-order="stroke" stroke-miterlimit="3" fill="#cbcbcb" style="font: 700 27px Arimo;">${name}</text></svg>`;
                        svgInput.oninput();
                    }
                } else {
                    // Show image upload, hide SVG input
                    imageGroup.style.display = 'block';
                    svgGroup.style.display = 'none';
                }
            },

            switchUploadTab(tabName) {
                // Update tab buttons
                document.querySelectorAll('.upload-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });

                // Update content sections
                document.querySelectorAll('.upload-content').forEach(content => {
                    content.classList.toggle('active', content.id === `upload-content-${tabName}`);
                });
            },

            async handleFileUpload(file) {
                // Validate file
                if (!file.type.startsWith('image/')) {
                    ErrorHandler.showToast('Please select an image file', 'error');
                    return;
                }

                if (file.size > 10 * 1024 * 1024) { // 5MB limit
                    ErrorHandler.showToast('File size must be less than 5MB', 'error');
                    return;
                }

                // Show upload status
                const uploadStatus = document.getElementById('upload-status');
                const uploadStatusText = document.getElementById('upload-status-text');
                const progressBar = document.getElementById('upload-progress-bar');
                const dropzone = document.getElementById('upload-dropzone');

                dropzone.style.display = 'none';
                uploadStatus.style.display = 'block';
                uploadStatusText.textContent = 'Uploading...';
                progressBar.style.width = '0%';

                // Create form data
                const formData = new FormData();
                formData.append('file', file);
                // Simulate progress (since fetch doesn't provide upload progress)
                const progressInterval = setInterval(() => {
                    const currentWidth = parseFloat(progressBar.style.width);
                    if (currentWidth < 90) {
                        progressBar.style.width = (currentWidth + 10) + '%';
                    }
                }, 100);

                try {


                    // Upload to your Cloudflare Pages function
                    const response = await fetch('/api/upload', {
                        method: 'POST',
                        body: formData
                    });

                    clearInterval(progressInterval);
                    progressBar.style.width = '100%';

                    if (!response.ok) {
                        throw new Error(`Upload failed: ${response.statusText}`);
                    }

                    const data = await response.json();

                    // Update preview with uploaded URL
                    this.uploadedImageUrl = data.url;
                    this.updateImagePreview(data.url);

                    uploadStatusText.textContent = 'Upload complete!';
                    uploadStatusText.style.color = '#2ecc71';

                    // Hide upload status after success
                    setTimeout(() => {
                        uploadStatus.style.display = 'none';
                        dropzone.style.display = 'block';
                    }, 2000);

                    ErrorHandler.showToast('Image uploaded!', 'success');

                } catch (error) {
                    clearInterval(progressInterval);
                    uploadStatusText.textContent = 'Failed to upload';
                    uploadStatusText.style.color = '#e74c3c';

                    // Reset after error
                    setTimeout(() => {
                        uploadStatus.style.display = 'none';
                        dropzone.style.display = 'block';
                    }, 3000);

                    ErrorHandler.showToast('Upload failed: ' + error.message, 'error');
                }
            },

            updateImagePreview(url) {
                const img = document.getElementById('preview-img');
                const placeholder = document.getElementById('preview-placeholder');
                const removeBtn = document.getElementById('remove-image');

                if (url) {
                    img.src = url;
                    img.style.display = 'block';
                    placeholder.style.display = 'none';
                    removeBtn.style.display = 'flex';

                    img.onerror = () => {
                        img.style.display = 'none';
                        placeholder.style.display = 'block';
                        placeholder.textContent = 'Invalid image';
                        removeBtn.style.display = 'none';
                    };
                } else {
                    this.clearImage();
                }
            },

            clearImage() {
                const img = document.getElementById('preview-img');
                const placeholder = document.getElementById('preview-placeholder');
                const removeBtn = document.getElementById('remove-image');
                const fileInput = document.getElementById('item-file-upload');
                const urlInput = document.getElementById('item-img');

                img.style.display = 'none';
                img.src = '';
                placeholder.style.display = 'block';
                placeholder.textContent = 'No image selected';
                removeBtn.style.display = 'none';
                fileInput.value = '';
                urlInput.value = '';
                this.uploadedImageUrl = null;
            },

            nextStep() {
                if (this.currentStep === 1) {
                    if (!this.newItemData.category) {
                        ErrorHandler.showToast('Please select a category', 'error');
                        return;
                    }
                    setTimeout(() => this.toggleInputMode(), 50);
                } else if (this.currentStep === 2) {
                    const name = document.getElementById('item-name').value.trim();
                    if (!name) {
                        ErrorHandler.showToast('Please enter an item name', 'error');
                        return;
                    }

                    const categoryItems = state.jsData[this.newItemData.category] || [];
                    if (categoryItems.some(item => item.name.toLowerCase() === name.toLowerCase())) {
                        ErrorHandler.showToast('An item with this name already exists in this category', 'error');
                        return;
                    }

                    this.newItemData.name = name;

                    // Handle SVG or Image based on type
                    if (this.newItemData.isTitle) {
                        const svgCode = document.getElementById('item-svg-input').value.trim();
                        if (!svgCode || !svgCode.startsWith('<svg')) {
                            ErrorHandler.showToast('Please provide valid SVG code', 'error');
                            return;
                        }
                        this.newItemData.svg = svgCode;
                        this.newItemData.img = ''; // Titles don't use img
                    } else {
                        this.newItemData.img = this.uploadedImageUrl || document.getElementById('item-img').value.trim() || '';
                        this.newItemData.svg = ''; // Regular items don't use svg
                    }

                    this.newItemData.price = document.getElementById('item-price').value.trim() || 'N/A';
                    this.newItemData.from = document.getElementById('item-from').value.trim().replace(/\n/g, '<br>') || '';
                    this.newItemData['price/code/rarity'] = document.getElementById('item-rarity').value.trim().replace(/\n/g, '<br>') || '';

                    this.updatePreview();
                }

                if (this.currentStep < 3) {
                    this.currentStep++;
                    this.updateStepDisplay();
                }
            },

            prevStep() {
                if (this.currentStep > 1) {
                    this.currentStep--;
                    this.updateStepDisplay();
                }
            },

            updateStepDisplay() {
                document.querySelectorAll('.step').forEach(step => {
                    const stepNum = parseInt(step.dataset.step);
                    step.classList.toggle('active', stepNum === this.currentStep);
                    step.classList.toggle('completed', stepNum < this.currentStep);
                });

                document.querySelectorAll('.step-content').forEach((content, index) => {
                    content.classList.toggle('active', index + 1 === this.currentStep);
                });

                document.getElementById('item-adder-back').style.display = this.currentStep > 1 ? 'inline-block' : 'none';
                document.getElementById('item-adder-next').style.display = this.currentStep < 3 ? 'inline-block' : 'none';
                document.getElementById('item-adder-add').style.display = this.currentStep === 3 ? 'inline-block' : 'none';

                if (this.currentStep === 1) {
                    document.getElementById('item-adder-next').disabled = !this.newItemData.category;
                } else {
                    document.getElementById('item-adder-next').disabled = false;
                }
            },

            updatePreview() {
                const previewCard = document.getElementById('item-preview-card');
                const item = {
                    ...this.newItemData,
                    tradable: !document.getElementById('item-untradable').checked,
                    new: document.getElementById('item-new').checked,
                    weekly: document.getElementById('item-weekly').checked,
                    weeklystar: document.getElementById('item-weeklystar').checked,
                    retired: document.getElementById('item-retired').checked,
                    premium: document.getElementById('item-premium').checked
                };

                // Handle SVG or Image display
                let imageDisplay = '';
                if (item.svg) {
                    imageDisplay = item.svg;
                } else if (item.img) {
                    imageDisplay = `<img src="${item.img}" alt="${item.name}" />`;
                } else {
                    imageDisplay = '<div style="height:80px;background:#333;"></div>';
                }

                previewCard.innerHTML = `
        <div class="item-card" style="pointer-events: none;">
            ${imageDisplay}
            <div class="item-name">${item.name}</div>
            <label class="price-label">${Utils.formatThousands(item.price) || ''}</label>
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #999;">
            <div>Category: ${this.newItemData.category}</div>
            ${item.from ? `<div>From: ${item.from.replace(/<br>/g, ', ')}</div>` : ''}
            <div style="margin-top: 5px;">
                ${item.new ? '<span class="tag-pill" style="background:#1abc9c33;color:#1abc9c;border-color:#1abc9c;margin:2px;">New</span>' : ''}
                ${item.weekly ? '<span class="tag-pill" style="background:#3498db33;color:#3498db;border-color:#3498db;margin:2px;">Weekly</span>' : ''}
                ${item.weeklystar ? '<span class="tag-pill" style="background:#f1c40f33;color:#f1c40f;border-color:#f1c40f;margin:2px;">Star</span>' : ''}
                ${item.retired ? '<span class="tag-pill" style="background:#9b59b633;color:#9b59b6;border-color:#9b59b6;margin:2px;">Retired</span>' : ''}
                ${item.premium ? '<span class="tag-pill" style="background:#e67e2233;color:#e67e22;border-color:#e67e22;margin:2px;">Premium</span>' : ''}
                ${!item.tradable ? '<span class="tag-pill" style="background:#e74c3c33;color:#e74c3c;border-color:#e74c3c;margin:2px;">Untradable</span>' : ''}
            </div>
        </div>
    `;
            },

            addItem() {
                const newItem = {
                    name: this.newItemData.name,
                    price: this.newItemData.price || 'N/A',
                    from: this.newItemData.from || '',
                    'price/code/rarity': this.newItemData['price/code/rarity'] || '',
                    tradable: !document.getElementById('item-untradable').checked,
                    new: document.getElementById('item-new').checked,
                    weekly: document.getElementById('item-weekly').checked,
                    weeklystar: document.getElementById('item-weeklystar').checked,
                    retired: document.getElementById('item-retired').checked,
                    premium: document.getElementById('item-premium').checked
                };

                // ADD THIS: Include svg field if it's a title
                if (this.newItemData.svg) {
                    newItem.svg = this.newItemData.svg;
                } else {
                    newItem.img = this.newItemData.img || '';
                }

                const category = this.newItemData.category;
                if (!state.jsData[category]) {
                    state.jsData[category] = [];
                }

                const categoryItems = state.jsData[category];
                let insertIndex = categoryItems.findIndex(item =>
                    item.name.toLowerCase() > newItem.name.toLowerCase()
                );

                if (insertIndex === -1) {
                    insertIndex = categoryItems.length;
                }

                categoryItems.splice(insertIndex, 0, newItem);
                state.allItems = Object.values(state.jsData).flat();

                // Mark as new item (not modified)
                ChangeTracker.markAsNew(newItem.name);

                // Record for undo
                UndoRedoManager.recordChange({
                    type: 'add',
                    itemName: newItem.name,
                    category: category,
                    newState: newItem
                });

                UI.renderItems();
                UI.renderShops();
                ChangeTracker.updateHighlights();

                ErrorHandler.showToast(`âœ“ Added "${newItem.name}" to ${category}`, 'success');

                this.closeModal();

                setTimeout(() => {
                    const newCard = document.querySelector(`[data-name="${newItem.name}"]`);
                    if (newCard) {
                        newCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        newCard.style.animation = 'pulse-highlight 1s ease-in-out 3';
                    }
                }, 100);
            },
            openModal() {
                this.modal.classList.remove('hidden');
                this.currentStep = 1;
                this.newItemData = {};
                this.uploadedImageUrl = null;
                this.updateStepDisplay();

                // Reset all form fields
                document.querySelectorAll('.category-option').forEach(b => b.classList.remove('selected'));
                document.getElementById('item-name').value = '';
                document.getElementById('item-img').value = '';
                document.getElementById('item-price').value = '';
                document.getElementById('item-from').value = '';
                document.getElementById('item-rarity').value = '';
                document.getElementById('item-untradable').checked = false;
                document.getElementById('item-new').checked = true;
                document.getElementById('item-weekly').checked = false;
                document.getElementById('item-weeklystar').checked = false;
                document.getElementById('item-retired').checked = false;
                document.getElementById('item-premium').checked = false;

                // Reset upload area
                this.clearImage();
                this.switchUploadTab('upload');
                document.getElementById('upload-status').style.display = 'none';
                document.getElementById('upload-dropzone').style.display = 'block';

                requestAnimationFrame(() => {
                    this.modal.style.opacity = '1';
                });
            },

            closeModal() {
                this.modal.classList.add('hidden');
                this.modal.style.opacity = '0';
            }
        };
        // ============================
        // Utility Functions
        // ============================

        const Utils = {
            async hash(text) {
                const data = new TextEncoder().encode(text);
                const hash = await crypto.subtle.digest('SHA-256', data);
                return Array.from(new Uint8Array(hash))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            },

            getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                return parts.length === 2 ? parts.pop().split(';').shift() : '';
            },

            setCookie(name, value, days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                document.cookie = `${name}=${value}; expires=${date.toUTCString()}; path=/`;
            },

            clearCookie(name) {
                document.cookie = `${name}=; Max-Age=0; path=/`;
            },

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            formatThousands(text) {
                text = String(text);
                return text.replace(/\b\d{4,}\b/g, match => {
                    const num = parseInt(match, 10);
                    return num >= 1000 ? (num / 1000).toString().replace(/\.0$/, '') + 'k' : match;
                });
            },

            createElement(tag, attrs = {}, children = []) {
                const el = document.createElement(tag);
                Object.entries(attrs).forEach(([key, value]) => {
                    if (key === 'style' && typeof value === 'object') {
                        Object.assign(el.style, value);
                    } else if (key === 'class') {
                        el.className = value;
                    } else if (key.startsWith('on')) {
                        el.addEventListener(key.slice(2).toLowerCase(), value);
                    } else {
                        el[key] = value;
                    }
                });
                children.forEach(child => {
                    if (typeof child === 'string') {
                        el.appendChild(document.createTextNode(child));
                    } else if (child) {
                        el.appendChild(child);
                    }
                });
                return el;
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            // Window resize
            resizer() {
                UI.renderItems(true);
                //CanvasArrow.updateSize();
            },

            // Improved debounce with immediate option
            debounce(func, wait, immediate = false) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        timeout = null;
                        if (!immediate) func(...args);
                    };

                    const callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);

                    if (callNow) func(...args);
                };
            },

            // Throttle function
            throttle(func, limit) {
                let inThrottle;
                return function (...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },

            // Improved event delegation
            delegate(parent, selector, event, handler) {
                parent.addEventListener(event, (e) => {
                    if (e.target.matches(selector)) {
                        handler.call(e.target, e);
                    }
                });
            },

            // Local storage with error handling
            storage: {
                get(key, defaultValue = null) {
                    try {
                        const item = localStorage.getItem(key);
                        return item ? JSON.parse(item) : defaultValue;
                    } catch (error) {
                        ErrorHandler.handle(error, 'localStorage get');
                        return defaultValue;
                    }
                },

                set(key, value) {
                    try {
                        localStorage.setItem(key, JSON.stringify(value));
                        return true;
                    } catch (error) {
                        ErrorHandler.handle(error, 'localStorage set');
                        return false;
                    }
                },

                remove(key) {
                    try {
                        localStorage.removeItem(key);
                        return true;
                    } catch (error) {
                        ErrorHandler.handle(error, 'localStorage remove');
                        return false;
                    }
                }
            }
        };

        // ============================
        // DOM Cache
        // ============================
        const DOM = {
            cache: new Map(),

            get(id) {
                if (!this.cache.has(id)) {
                    const element = document.getElementById(id);
                    if (element) {
                        this.cache.set(id, element);
                    }
                }
                return this.cache.get(id);
            },

            query(selector) {
                return document.querySelector(selector);
            },

            queryAll(selector) {
                return document.querySelectorAll(selector);
            },

            clear() {
                this.cache.clear();
            }
        };

        new ResizeObserver(Utils.resizer).observe(DOM.get('lists-section'));
        // ============================
        // WebSocket Manager
        // ============================
        class WebSocketManager {
            constructor(url, name, handlers) {
                this.url = url;
                this.name = name;
                this.handlers = handlers;
                this.backoff = 1000;
                this.maxBackoff = 30000;
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.isIntentionallyClosed = false;
                this.heartbeatInterval = null;

                this.connect();
            }

            connect() {
                if (this.isIntentionallyClosed) return;

                try {
                    this.ws = new WebSocket(this.url);
                    this.setupEventHandlers();
                } catch (error) {
                    ErrorHandler.handle(error, `WebSocket ${this.name} connection`);
                    this.scheduleReconnect();
                }
            }

            setupEventHandlers() {
                this.ws.onopen = () => {
                    this.backoff = 1000;
                    this.reconnectAttempts = 0;
                    this.startHeartbeat();

                    if (this.handlers.onOpen) {
                        this.handlers.onOpen();
                    }
                };

                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (this.handlers.onMessage) {
                            this.handlers.onMessage(data);
                        }
                    } catch (error) {
                        ErrorHandler.handle(error, `WebSocket ${this.name} message parsing`);
                    }
                };

                this.ws.onclose = (event) => {
                    this.stopHeartbeat();

                    if (!this.isIntentionallyClosed) {
                        if (this.reconnectAttempts < this.maxReconnectAttempts) {
                            this.scheduleReconnect();
                        } else {
                            ErrorHandler.handle(
                                new Error('Max reconnection attempts reached'),
                                `WebSocket ${this.name}`
                            );
                        }
                    }

                    if (this.handlers.onClose) {
                        this.handlers.onClose(event);
                    }
                };

                this.ws.onerror = (error) => {
                    ErrorHandler.handle(error, `WebSocket ${this.name}`);
                    if (this.handlers.onError) {
                        this.handlers.onError(error);
                    }
                };
            }

            scheduleReconnect() {
                this.reconnectAttempts++;
                setTimeout(() => {
                    this.connect();
                }, this.backoff);

                this.backoff = Math.min(this.backoff * 2, this.maxBackoff);
            }

            startHeartbeat() {
                this.heartbeatInterval = setInterval(() => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.send({ type: 'ping' });
                    }
                }, 30000); // 30 seconds
            }

            stopHeartbeat() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
            }

            // In WebSocketManager class, verify the send method:
            send(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        const message = typeof data === 'string' ? data : JSON.stringify(data);
                        this.ws.send(message);
                        return true;
                    } catch (error) {
                        ErrorHandler.handle(error, `WebSocket ${this.name} send`);
                        return false;
                    }
                } else {
                    console.warn(`WebSocket ${this.name} not ready, state: ${this.ws?.readyState}`);
                    return false;
                }
            }

            close() {
                this.isIntentionallyClosed = true;
                this.stopHeartbeat();

                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
            }
        };

        // ============================
        // Performance Monitor
        // ============================
        const PerformanceMonitor = {
            timers: new Map(),

            start(label) {
                this.timers.set(label, performance.now());
            },

            end(label) {
                const startTime = this.timers.get(label);
                if (startTime) {
                    const duration = performance.now() - startTime;
                    console.log(`${label}: ${duration.toFixed(2)}ms`);
                    this.timers.delete(label);
                    return duration;
                }
            },

            measure(fn, label) {
                this.start(label);
                const result = fn();
                this.end(label);
                return result;
            }
        };
        // ============================
        // API Manager
        // ============================
        const API = {
            async fetchWithRetry(url, options = {}, retries = 3) {
                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(url, options);
                        if (response.ok) return response;
                        if (i === retries - 1) throw new Error(`Failed after ${retries} attempts`);
                    } catch (error) {
                        if (i === retries - 1) throw error;
                        await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
                    }
                }
            },

            async loadData() {
                try {
                    const [versionRes, gistRes] = await Promise.all([
                        API.fetchWithRetry(CONFIG.API_URLS.LATEST_VERSION, { cache: 'no-store' }),
                        API.fetchWithRetry(CONFIG.API_URLS.GIST_VERSION, { cache: 'no-store' })
                    ]);

                    const data = await gistRes.json();
                    const raw = data.files?.['auto.json']?.content;
                    state.jsData = raw ? JSON.parse(raw) : {};
                    state.allItems = Object.values(state.jsData).flat();

                    if (versionRes) {
                        const text = await versionRes.text();
                        const [, v] = text.split('|');
                        state.currentVersion = v || '';
                    }

                    state.gistVersion = data.history?.[0]?.version || '';

                    // Load demand ratings and merge with items
                    await this.loadDemandRatings();

                    return true;
                } catch (error) {
                    console.error('Failed to load data:', error);
                    return false;
                }
            },

            async loadDemandRatings() {
                try {
                    const response = await fetch('https://emwiki.com/api/demand/all');
                    const data = await response.json();

                    if (data.demand && Array.isArray(data.demand)) {
                        const demandMap = new Map();
                        data.demand.forEach(d => {
                            const key = `${d.category}-${d.item_name}`;
                            demandMap.set(key, d.demand);
                        });

                        // Merge demand into all items
                        Object.entries(state.jsData).forEach(([category, items]) => {
                            if (Array.isArray(items)) {
                                items.forEach(item => {
                                    const key = `${category}-${item.name}`;
                                    item.demand = demandMap.get(key) || 0;
                                });
                            }
                        });

                        state.allItems = Object.values(state.jsData).flat();
                        console.log('Loaded demand ratings for items');

                        // Update original items with demand data so ChangeTracker can detect changes
                        state.allItems.forEach(item => {
                            if (ChangeTracker.originalItems.has(item.name)) {
                                ChangeTracker.originalItems.set(item.name, JSON.stringify(item));
                            }
                        });
                    }
                } catch (error) {
                    console.error('Failed to load demand ratings:', error);
                }
            },

            async saveData() {
                // Track price changes before saving
                this.updatePriceHistory();

                // Clean up the data before saving
                const cleanedData = JSON.parse(JSON.stringify(state.jsData));

                Object.values(cleanedData).forEach(categoryItems => {
                    if (Array.isArray(categoryItems)) {
                        categoryItems.forEach(item => {
                            if (!item.price || item.price === '' || item.price === 'N/A' || item.price === 'undefined') {
                                item.price = '0';
                            }
                            if (!item.priceHistory) {
                                item.priceHistory = [];
                            }
                        });
                    }
                });

                // âœ… MINIFY THE JSON (no spaces/indents)
                const minifiedContent = JSON.stringify(cleanedData);

                const response = await fetch(CONFIG.API_URLS.UPDATE_GIST, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content: cleanedData,  // Send as object, server will stringify
                        username: state.adminName,
                        version: state.gistVersion
                    })
                });

                // Also save demand ratings to database
                if (response.ok) {
                    await this.saveDemandRatings();
                }

                return response;
            },

            async saveDemandRatings() {
                try {
                    // Collect all items with demand ratings
                    const demandItems = [];

                    Object.entries(state.jsData).forEach(([category, items]) => {
                        if (Array.isArray(items)) {
                            items.forEach(item => {
                                if (item.demand !== undefined) {
                                    demandItems.push({
                                        item_name: item.name,
                                        category: category,
                                        demand: item.demand
                                    });
                                }
                            });
                        }
                    });

                    if (demandItems.length === 0) return;

                    // Bulk save to API
                    const response = await fetch('https://emwiki.com/api/demand/bulk', {
                        method: 'POST',
                        credentials: 'include',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ items: demandItems })
                    });

                    if (!response.ok) {
                        console.error('Failed to save demand ratings:', await response.text());
                    } else {
                        console.log(`Saved ${demandItems.length} demand ratings`);
                    }
                } catch (error) {
                    console.error('Error saving demand ratings:', error);
                }
            },

            // Add this new method to API object:
            // Add this new method to API object:
            updatePriceHistory() {
                const now = Date.now();

                state.allItems.forEach(item => {
                    if (!item.priceHistory) {
                        item.priceHistory = [];
                    }

                    const isModified = ChangeTracker.isModifiedItem(item.name);
                    const isNew = ChangeTracker.isNewItem(item.name);

                    if (isModified || isNew) {
                        const originalJson = ChangeTracker.originalItems.get(item.name);
                        let oldPrice = null;

                        if (originalJson && !isNew) {
                            const original = JSON.parse(originalJson);
                            oldPrice = original.price;  // â† Use raw price, not normalized
                        }

                        const currentPrice = item.price;  // â† Use raw price

                        // Only add to history if price actually changed
                        if (oldPrice !== currentPrice) {
                            const lastEntry = item.priceHistory[item.priceHistory.length - 1];

                            // Convert price to number for storage (handle ranges by taking first value)
                            let priceValue = 0;
                            if (currentPrice && currentPrice !== 'N/A') {
                                // If it's a range like "50-100", take the first number
                                const match = String(currentPrice).match(/^\d+/);
                                priceValue = match ? parseInt(match[0]) : 0;
                            }

                            // âœ… NEW: Skip if price is 0
                            if (priceValue === 0) {
                                return; // Don't add to history
                            }

                            const shouldAdd = !lastEntry || lastEntry.price !== priceValue;

                            if (shouldAdd) {
                                item.priceHistory.push({
                                    price: priceValue,
                                    timestamp: now,
                                    admin: state.adminName
                                });

                                // Keep only last 50 entries
                                if (item.priceHistory.length > 50) {
                                    item.priceHistory = item.priceHistory.slice(-50);
                                }
                            }
                        }
                    }
                });
            },
            // Add this helper method to API object:
            normalizePrice(price) {
                if (!price || price === '' || price === 'N/A' || price === 'undefined') {
                    return '0';
                }
                // Remove any non-numeric characters except decimals
                const cleaned = String(price).replace(/[^\d.]/g, '');
                return cleaned || '0';
            },

            async loadHistory() {
                const response = await API.fetchWithRetry(CONFIG.API_URLS.HISTORY);
                return await response.json();
            }
        };

        // ============================
        // UI Components
        // ============================
        const UI = {
            showLoading(element, text = 'Loading...') {
                element.innerHTML = `<div class="loading">${text}</div>`;
            },

            showError(element, text = 'An error occurred') {
                element.innerHTML = `<div class="error">${text}</div>`;
            },

            createItemCard(item) {
                const card = Utils.createElement('div', {
                    class: `item-card ${state.changedItems.has(item.name) ? 'changed' : ''}`,

                });
                card.dataset.name = item.name;

                const img = Utils.createElement('img', {
                    src: item.img || '',
                    alt: item.name,
                    onError: function () { this.style.display = 'none'; }
                });

                if (item.svg) {
                    card.innerHTML = item.svg;
                    // Ensure SVG scales properly
                    const svg = card.querySelector('svg');
                    if (svg) {
                        svg.style.width = '100%';
                        svg.style.height = 'auto';
                    }
                }
                const name = Utils.createElement('div', {
                    class: 'item-name',
                    textContent: item.name
                });

                const priceLabel = Utils.createElement('label', {
                    class: `price-label ${!state.filters.showPrices ? 'hidden' : ''}`,
                    textContent: Utils.formatThousands(item.price) || ''
                });

                if (item.price <= 0 || item.price === 'N/A') {
                    priceLabel.style.display = 'none';
                }

                if (img.src) card.appendChild(img);
                card.appendChild(name);
                card.appendChild(priceLabel);

                card.addEventListener('click', () => {
                    card.style.transition = 'all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1)';
                    card.style.transform = 'scale(0.9)';
                    card.style.filter = 'opacity(0.5)';

                    setTimeout(() => {
                        card.style.transform = '';
                        card.style.filter = '';
                        setTimeout(() => {
                            card.style.transition = '';
                        }, 200);
                    }, 200);

                    QuickEditor.open(item);
                });

                // Auto-size font
                requestAnimationFrame(() => {
                    name.style.fontSize = '13px';
                    let fontsize = 13;
                    while (name.offsetWidth > card.offsetWidth - 18 && fontsize > 8) {
                        fontsize -= 1;
                        name.style.fontSize = `${fontsize}px`;
                    }
                });

                return card;
            },

            renderShops() {
                const container = DOM.get('shops-container');
                container.innerHTML = '';

                const shops = [
                    { name: 'Weekly Shop', key: 'weekly' },
                    { name: 'Star Shop', key: 'weeklystar' }
                ];

                const wrapper = Utils.createElement('div', {
                    style: { display: 'flex', gap: '12px', marginBottom: '28px', flexWrap: 'wrap' }
                });

                shops.forEach(shop => {
                    const panel = Utils.createElement('div', {
                        class: 'panel',
                        style: { flex: 1 }
                    });

                    const title = Utils.createElement('div', {
                        textContent: shop.name,
                        style: {
                            fontWeight: '700',
                            marginBottom: '8px',
                            fontVariantCaps: 'all-small-caps',
                            marginTop: '-10px',
                            fontSize: '20px'
                        }
                    });

                    const grid = Utils.createElement('div', {
                        class: 'grid',
                        id: `${shop.key}-items`
                    });

                    state.allItems
                        .filter(item => item[shop.key])
                        .forEach(item => grid.appendChild(UI.createItemCard(item)));

                    panel.appendChild(title);
                    panel.appendChild(grid);
                    wrapper.appendChild(panel);
                });

                container.appendChild(wrapper);
            },

            renderFilterControls() {
                const container = DOM.get('filter-controls');
                container.innerHTML = '';

                // Search input
                const searchInput = Utils.createElement('input', {
                    id: 'search',
                    placeholder: 'Search items...',
                    value: state.filters.search,
                    autocomplete: "off",
                    onInput: Utils.debounce((e) => {
                        state.filters.search = e.target.value;
                        UI.renderItems();
                    }, 300)
                });

                const i = Utils.createElement('span', {
                    id: 'search-icon',
                    class: 'icon',
                    innerHTML: '<span class="icon search-icon"></span>',
                });

                // Category filter
                const categorySelect = Utils.createElement('select', {
                    id: 'category-filter',
                    value: state.filters.category,
                    onChange: (e) => {
                        state.filters.category = e.target.value;
                        UI.renderItems();
                    }
                });

                const allOption = Utils.createElement('option', {
                    value: 'all',
                    textContent: 'All categories'
                });
                categorySelect.appendChild(allOption);

                Object.keys(state.jsData).forEach(key => {
                    const option = Utils.createElement('option', {
                        value: key,
                        textContent: key.charAt(0).toUpperCase() + key.slice(1)
                    });
                    categorySelect.appendChild(option);
                });

                // Gamenight toggle
                const gamenightBtn = Utils.createElement('button', {
                    class: `small-btn ${state.filters.gamenightOnly ? '' : 'ghost'}`,
                    innerHTML: '<span class="icon gamenight-icon"></span>Gamenight',
                    onClick: () => {
                        state.filters.gamenightOnly = !state.filters.gamenightOnly;
                        gamenightBtn.classList.toggle('ghost');
                        UI.renderItems();
                    }
                });

                // Newest toggle
                const newestBtn = Utils.createElement('button', {
                    class: `small-btn ${state.filters.newestOnly ? '' : 'ghost'}`,
                    innerHTML: '<span class="icon newest-icon"></span>Newest',
                    onClick: () => {
                        state.filters.newestOnly = !state.filters.newestOnly;
                        newestBtn.classList.toggle('ghost');
                        UI.renderItems();
                    }
                });

                // Sort select
                const sortSelect = Utils.createElement('select', {
                    id: 'sort-select',
                    value: state.filters.sort,
                    onChange: (e) => {
                        state.filters.sort = e.target.value;
                        UI.renderItems();
                    }
                });

                const sortOptions = [
                    { value: 'default', text: 'Default' },
                    { value: 'az', text: 'A â†’ Z' },
                    { value: 'za', text: 'Z â†’ A' },
                    { value: 'high', text: '$$$ â†’ $' },
                    { value: 'low', text: '$ â†’ $$$' }
                ];

                sortOptions.forEach(opt => {
                    const option = Utils.createElement('option', {
                        value: opt.value,
                        textContent: opt.text
                    });
                    sortSelect.appendChild(option);
                });

                // Show prices button
                const pricesBtn = Utils.createElement('button', {
                    class: `small-btn ${state.filters.showPrices ? '' : 'ghost'}`,
                    innerHTML: '<span class="icon prices-icon"></span>Show Prices',
                    onClick: () => {
                        state.filters.showPrices = !state.filters.showPrices;
                        pricesBtn.classList.toggle('ghost');
                        DOM.queryAll('.price-label').forEach(tag => {
                            tag.classList.toggle('hidden');
                        });
                    }
                });
                pricesBtn.click();
                container.appendChild(searchInput);
                container.appendChild(i);
                container.appendChild(categorySelect);
                container.appendChild(newestBtn);
                container.appendChild(sortSelect);
                container.appendChild(pricesBtn);
                container.appendChild(gamenightBtn);

            },

            renderItems(keepPage = false) {
                ChangeTracker.updateHighlights();
                if (!keepPage) state.currentPage = 1;

                const container = DOM.get('all-items');
                container.innerHTML = '';

                // Calculate grid
                const containerWidth = container.clientWidth;
                const columns = Math.floor((containerWidth + CONFIG.UI.GRID_GAP) / (CONFIG.UI.ITEM_MIN_WIDTH + CONFIG.UI.GRID_GAP));
                container.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;

                const rows = 2;
                state.itemsPerPage = columns * rows;

                // Apply filters
                let filtered = state.allItems.slice();

                if (state.filters.category !== 'all') {
                    filtered = state.jsData[state.filters.category] ? state.jsData[state.filters.category].slice() : [];
                }

                if (state.filters.gamenightOnly) {
                    filtered = filtered.filter(i => i.from && i.from.toLowerCase().includes('gamenight'));
                }

                if (state.filters.search) {
                    const fuse = new Fuse(filtered, {
                        keys: ['name'],
                        threshold: 0.35
                    });
                    filtered = fuse.search(state.filters.search).map(r => r.item);
                }

                // Apply sorting
                const sortFunctions = {
                    'az': (a, b) => a.name.localeCompare(b.name),
                    'za': (a, b) => b.name.localeCompare(a.name),
                    'high': (a, b) => {
                        // Convert prices, treating 'o/c' as highest value
                        const priceA = a.price?.toLowerCase() === 'o/c' ? Number.MAX_SAFE_INTEGER : (parseInt(a.price || 0) || 0);
                        const priceB = b.price?.toLowerCase() === 'o/c' ? Number.MAX_SAFE_INTEGER : (parseInt(b.price || 0) || 0);
                        return priceB - priceA;
                    },
                    'low': (a, b) => {
                        // Convert prices, treating 'o/c' as highest value
                        const priceA = a.price?.toLowerCase() === 'o/c' ? Number.MAX_SAFE_INTEGER : (parseInt(a.price || 0) || 0);
                        const priceB = b.price?.toLowerCase() === 'o/c' ? Number.MAX_SAFE_INTEGER : (parseInt(b.price || 0) || 0);
                        return priceA - priceB;
                    }
                };

                if (sortFunctions[state.filters.sort]) {
                    filtered.sort(sortFunctions[state.filters.sort]);
                }

                if (state.filters.newestOnly) {
                    filtered = filtered.filter(i => i.new);
                }



                state.filteredItems = filtered;

                // Render current page
                const start = (state.currentPage - 1) * state.itemsPerPage;
                const end = start + state.itemsPerPage;

                filtered.slice(start, end).forEach(item => {
                    container.appendChild(UI.createItemCard(item));
                });

                UI.renderPagination();
                ChangeTracker.updateHighlights();
            },

            renderPagination() {
                const container = DOM.get('pagination-controls');
                container.innerHTML = '';

                const totalPages = Math.max(1, Math.ceil(state.filteredItems.length / state.itemsPerPage));

                const wrapper = Utils.createElement('div', {
                    style: {
                        display: 'flex',
                        justifyContent: 'center',
                        gap: '8px',
                        marginTop: '19px',
                        alignItems: 'center'
                    }
                });

                const prevBtn = Utils.createElement('button', {
                    class: 'small-btn ghost',
                    textContent: 'â—€ Prev',
                    disabled: state.currentPage === 1,
                    style: { opacity: state.currentPage === 1 ? '0.5' : '1' },
                    onClick: () => {
                        if (state.currentPage > 1) {
                            state.currentPage--;
                            UI.renderItems(true);
                        }
                    }
                });

                const pageCount = Utils.createElement('div', {
                    class: 'note',
                    textContent: `Page ${state.currentPage} of ${totalPages}`
                });

                const nextBtn = Utils.createElement('button', {
                    class: 'small-btn ghost',
                    textContent: 'Next â–¶',
                    disabled: state.currentPage === totalPages,
                    style: { opacity: state.currentPage === totalPages ? '0.5' : '1' },
                    onClick: () => {
                        if (state.currentPage < totalPages) {
                            state.currentPage++;
                            UI.renderItems(true);
                        }
                    }
                });

                wrapper.appendChild(prevBtn);
                wrapper.appendChild(pageCount);
                wrapper.appendChild(nextBtn);
                container.appendChild(wrapper);
            },

            setupDragDrop() {
                const FLAG_PANELS = { 'weekly-items': 'weekly', 'weeklystar-items': 'weeklystar' };

                // master list
                new Sortable(DOM.get('all-items'), {
                    group: {
                        name: 'all',
                        pull: 'clone',
                        put: true,
                    },
                    animation: 100,
                    sort: false,

                    onAdd(evt) {
                        const name = evt.item.dataset.name;
                        evt.item.remove(); // remove cloned item
                        evt.clone.remove(); // remove original dragged item
                        let key = evt.from.id == 'weeklystar-items' ? 'weeklystar' : 'weekly';
                        for (const arr of Object.values(state.jsData)) {
                            const it = arr.find(x => x.name === name);
                            if (it) { it[key] = false; }
                            if (it === state.currentEditingItem) { QuickEditor.open(it); }
                        }

                        //UI.renderItems(true);
                    },
                    onStart: evt => {
                        evt.item.style.opacity = '0.25';
                        DOM.get('weekly-items').children.length < 4 ? DOM.get('weekly-items').parentElement.style.filter = 'brightness(1.3)' : DOM.get('weekly-items').parentElement.classList.add('full');
                        DOM.get('weeklystar-items').children.length < 4 ? DOM.get('weeklystar-items').parentElement.style.filter = 'brightness(1.3)' : DOM.get('weeklystar-items').parentElement.classList.add('full');
                    },
                    onEnd: evt => {
                        evt.item.style.opacity = '';
                        DOM.get('weekly-items').parentElement.style.filter = '';
                        DOM.get('weeklystar-items').parentElement.style.filter = '';
                        DOM.get('weekly-items').parentElement.classList.remove('full');
                        DOM.get('weeklystar-items').parentElement.classList.remove('full');
                    }
                });

                // helper to check duplicates
                function alreadyInList(toEl, dragEl) {
                    //TODO: notify user about full list
                    if (toEl.children.length >= 4) return true;
                    const name = dragEl.dataset.name;

                    return Array.from(toEl.children).some(el => el.dataset.name === name);
                }

                Object.entries(FLAG_PANELS).forEach(([id, key]) => {
                    new Sortable(DOM.get(id), {
                        group: {
                            name: 'shared-flags',
                            pull: 'clone',
                            put: (to, from, dragEl) => {
                                return !alreadyInList(to.el, dragEl);
                            }
                        },
                        animation: 100,
                        sort: false,

                        onAdd(evt) {
                            const name = evt.item.dataset.name;
                            for (const arr of Object.values(state.jsData)) {
                                const it = arr.find(x => x.name === name);
                                if (it) { it[key] = true; }
                                if (it === state.currentEditingItem) { QuickEditor.open(it); }
                            }

                            UI.renderItems(true);
                        },
                        onStart: evt => { evt.item.style.opacity = '0.25'; DOM.get('all-items').parentElement.classList.add('delete-zone'); },
                        onEnd: evt => { evt.item.style.opacity = ''; DOM.get('all-items').parentElement.classList.remove('delete-zone'); }
                    });
                });
            }
        };

        // ============================
        // Quick Editor
        // ============================
        const QuickEditor = {
            TAG_COLORS: {
                New: "#1abc9c",
                Weekly: "#3498db",
                Star: "#f1c40f",
                Retired: "#9b59b6",
                Premium: "#e67e22",
                Untradable: "#e74c3c",
                Removed: "#95a5a6"
            },

            TAG_TO_PROP: {
                New: "new",
                Weekly: "weekly",
                Star: "weeklystar",
                Retired: "retired",
                Premium: "premium",
                Untradable: "tradable",
                Removed: "removed"
            },

            ICON_MAP: {
                Robux: "./imgs/cf8ZvY7.png",
                Coins: "./imgs/Coin.webp",
                Stars: "./imgs/WKeX5AS.png",
                Visors: "./imgs/7IoLZCN.png",
                Pumpkins: "./imgs/bHRBTrU.png",
                Eggs: "./imgs/qMxjgQy.png",
                Opals: "./imgs/wwMMAvr.png",
                Opal: "./imgs/wwMMAvr.png",
                Baubles: "./imgs/bauble.png",
                Bauble: "./imgs/bauble.png",
                Tokens: "./imgs/Cy9r140.png",
                Token: "./imgs/Cy9r140.png"
            },

            tagMenu: null,
            titleInput: null,
            imageInput: null,

            open(item) {

                // Don't capture original for new items
                if (!ChangeTracker.isNewItem(item.name)) {
                    // Only capture if not already captured
                    if (!ChangeTracker.originalItems.has(item.name)) {
                        ChangeTracker.originalItems.set(item.name, JSON.stringify(item));
                    }
                }
                state.currentEditingItem = item;

                // Initialize draggable panel if not already done
                if (!DraggablePanelManager.state.isInitialized) {
                    DraggablePanelManager.init();
                }

                // Show the panel
                DraggablePanelManager.show();

                const modal = DOM.get('quick-editor-modal');
                const content = DOM.get('quick-editor-content');
                const priceInput = DOM.get('quick-editor-price');

                if (DraggablePanelManager.state.isMobile) {
                    modal.classList.add('mobile-mode');
                    content.classList.add('mobile-mode');
                } else {
                    modal.classList.remove('mobile-mode');
                    content.classList.remove('mobile-mode');
                }

                content.classList.remove('initial');

                // Setup editable title with edit icon
                this.setupEditableTitle(item);

                // Setup editable image
                if (document.querySelectorAll('#svg-editor')) {
                    document.querySelectorAll('#svg-editor').forEach(editor => editor.remove());
                }
                this.setupEditableImage(item);
                // Setup SVG editor if item has svg field
                this.setupSVGEditor(item);
                // Setup price input
                priceInput.placeholder = "RAP";
                priceInput.value = '';

                if (item.price >= 0 || item.price !== 'N/A') {
                    priceInput.value = item.price || '';
                }

                priceInput.onchange = () => {
                    if (priceInput.value.trim() == '') {
                        item.price = 'N/A';
                    }
                    const previousState = JSON.parse(JSON.stringify(state.currentEditingItem));
                    state.currentEditingItem.price = priceInput.value.trim();

                    ChangeTracker.checkModifications(state.currentEditingItem);

                    if (!UndoRedoManager.isApplyingChange &&
                        previousState.price !== state.currentEditingItem.price) {

                        UndoRedoManager.recordChange({
                            type: 'edit',
                            itemName: state.currentEditingItem.name,
                            previousState: previousState,
                            newState: JSON.parse(JSON.stringify(state.currentEditingItem))
                        });
                    }

                    UI.renderItems(true);
                    UI.renderShops();
                    ChangeTracker.updateHighlights();
                };

                // Setup demand rating
                this.setupDemandRating(item);

                // Setup buttons
                this.setupButtons();

                // Render components
                this.renderTags(item);
                this.renderDescriptions(item);
                this.renderPrices(item);

                // Setup modal click handler for closing tag menu
                this.setupModalClickHandler(content);

                // Show modal
                modal.classList.add('show');
                modal.classList.remove('hidden');
            },

            setupEditableTitle(item) {
                const titleContainer = DOM.get('quick-editor-title');

                // Create title display with edit icon
                titleContainer.innerHTML = `
            <span id="title-text">${item.name}</span>
            <button id="edit-title-btn" style="
                background: none;
                border: none;
                cursor: pointer;
                opacity: 0.7;
                margin-left: -3px;
                transition: opacity 0.2s;
                display: inline-flex;
                align-items: center;
                padding: 4px;
                transform: translateY(-4px);
            " title="Edit name">
                <span class="icon" style="
                    mask-image: url('data:image/svg+xml,%3Csvg viewBox=%22-2.5 -2.5 24 24%22 xmlns=%22http://www.w3.org/2000/svg%22%3E%3Cpath d=%22M12.238 5.472L3.2 14.51l-.591 2.016 1.975-.571 9.068-9.068-1.414-1.415zM13.78 3.93l1.414 1.414 1.318-1.318a.5.5 0 0 0 0-.707l-.708-.707a.5.5 0 0 0-.707 0L13.781 3.93zm3.439-2.732l.707.707a2.5 2.5 0 0 1 0 3.535L5.634 17.733l-4.22 1.22a1 1 0 0 1-1.237-1.241l1.248-4.255 12.26-12.26a2.5 2.5 0 0 1 3.535 0z%22/%3E%3C/svg%3E');
                    width: 19px;
                    height: 19px;
                    background: #c5d8e9a1;
                "></span>
            </button>
        `;

                const editBtn = document.getElementById('edit-title-btn');
                editBtn.onmouseover = () => { editBtn.style.opacity = '1'; };
                editBtn.onmouseout = () => { editBtn.style.opacity = '0.7'; };

                editBtn.onclick = () => this.editTitle(item);

                // Also allow double-click on title to edit
                document.getElementById('title-text').ondblclick = () => this.editTitle(item);
            },

            editTitle(item) {
                const titleContainer = DOM.get('quick-editor-title');
                const currentName = item.name;

                // Create input field
                titleContainer.innerHTML = `
            <input type="text" id="title-edit-input" value="${currentName}" style="
                width: 80%;
                background: #111827;
                border: 1px solid #555;
                padding: 4px 8px;
                color: #eee;
                font-size:  21px;
                border-radius: 4px;
            ">
            <button id="save-title-btn" class="small-btn success" style="

                padding: 4px 12px;
                margin-left: 8px;

            ">âœ“</button>
        `;

                const input = document.getElementById('title-edit-input');
                const saveBtn = document.getElementById('save-title-btn');


                // Focus and select input
                input.focus();
                input.select();

                const saveName = () => {
                    const newName = input.value.trim();

                    if (newName && newName !== currentName) {
                        // Check if name already exists in the same category
                        const category = Object.entries(state.jsData).find(([cat, items]) =>
                            items.some(i => i === item)
                        )?.[0];

                        if (category) {
                            const exists = state.jsData[category].some(i =>
                                i !== item && i.name.toLowerCase() === newName.toLowerCase()
                            );

                            if (exists) {
                                ErrorHandler.showToast('An item with this name already exists', 'error');
                                return;
                            }
                        }

                        const previousState = JSON.parse(JSON.stringify(item));
                        item.name = newName;

                        ChangeTracker.checkModifications(item, previousState.name);

                        if (!UndoRedoManager.isApplyingChange) {
                            UndoRedoManager.recordChange({
                                type: 'edit',
                                itemName: previousState.name,
                                previousState: previousState,
                                newState: JSON.parse(JSON.stringify(item))
                            });
                        }

                        UI.renderItems(true);
                        UI.renderShops();
                        ChangeTracker.updateHighlights();
                        ErrorHandler.showToast('Name updated', 'success');
                    }

                    // Restore display
                    this.setupEditableTitle(item);
                };

                const cancel = () => {
                    this.setupEditableTitle(item);
                };

                // Event handlers
                saveBtn.onclick = saveName;


                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveName();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancel();
                    }
                };
            },

            setupEditableImage(item) {
                const img = DOM.get('quick-editor-img');
                const container = img.parentElement;

                // Create image container with edit overlay
                if (!document.getElementById('image-edit-container')) {
                    const imageContainer = document.createElement('div');
                    imageContainer.id = 'image-edit-container';
                    imageContainer.style.cssText = `
                position: relative;
                display: inline-block;
                cursor: pointer;
            `;

                    container.insertBefore(imageContainer, img);
                    imageContainer.appendChild(img);

                    // Create edit overlay
                    const editOverlay = document.createElement('div');
                    editOverlay.id = 'image-edit-overlay';
                    editOverlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.7);
                display: none;
                align-items: center;
                justify-content: center;
                border-radius: 8px;
                backdrop-filter: blur(2px);
            `;

                    editOverlay.innerHTML = `
                    
                <button style="
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    color: white;
                    padding: 6px 9px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                    margin: 15px;
                    font-variant: all-petite-caps;
                    display: flex;
                    align-items: center;
                    gap: 0px;
                " onclick="document.getElementById('edit-image-input').click();">
                <input type="file" accept="image/*" style="display:none" id="edit-image-input">
                    <span class="icon" style="
                        mask-image: url('data:image/svg+xml,%3Csvg viewBox=%220 0 24 24%22 xmlns=%22http://www.w3.org/2000/svg%22%3E%3Cpath d=%22M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z%22/%3E%3C/svg%3E');
                        width: 32px;
                        height: 32px;
                        margin: 0px;
                    "></span>
                    Change Image
                </button>
            `;

                    imageContainer.appendChild(editOverlay);

                    // Show overlay on hover
                    imageContainer.onmouseenter = () => {
                        editOverlay.style.display = 'flex';
                    };

                    imageContainer.onmouseleave = () => {
                        editOverlay.style.display = 'none';
                    };

                }

                const fileInput = document.getElementById('edit-image-input');

                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.handleFileUpload(item, file, img);
                    }
                };


                // Set image
                if (item.img) {
                    img.src = item.img;
                    img.style.display = 'block';
                } else {
                    img.style.display = 'none';
                }
            },

            setupSVGEditor(item) {
                // Check if this is a title item (has svg field)
                const isTitle = !!item.svg;

                if (!isTitle) return;

                // Hide the image editor
                const imgContainer = document.getElementById('quick-editor-img');
                if (imgContainer) imgContainer.style.display = 'none';

                // Create SVG editor
                const svgEditor = document.createElement('div');
                svgEditor.id = 'svg-editor';

                svgEditor.innerHTML = `
        
        <textarea id="svg-input" placeholder="Paste SVG code here..." 
            style="width: -webkit-fill-available; min-height: 120px; padding: 8px; background: #1f2937; 
            border: 1px solid #374151; border-radius: 4px; color: white; font-size: 12px;
            font-family: monospace; resize: vertical;">${item.svg || ''}</textarea>
        
        <div id="svg-preview" style="margin-top: 12px; padding: 12px; background: #111827; 
            border-radius: 4px; min-height: 60px; display: flex; align-items: center; 
            justify-content: center;">
            ${item.svg || '<span style="color: #666;">Preview will appear here</span>'}
        </div>
        
        <button id="apply-svg-btn" class="small-btn" style="margin-top: 12px; width: 100%;">
            Apply SVG
        </button>
    `;

                // Insert after image
                const img = DOM.get('image-edit-container');
                img.parentNode.insertBefore(svgEditor, img.nextSibling);

                // Live preview on input
                const svgInput = document.getElementById('svg-input');
                const svgPreview = document.getElementById('svg-preview');

                svgInput.addEventListener('input', () => {
                    const svgCode = svgInput.value.trim();
                    if (svgCode) {
                        svgPreview.innerHTML = svgCode;
                    } else {
                        svgPreview.innerHTML = '<span style="color: #666;">Preview will appear here</span>';
                    }
                    svgPreview.querySelector('svg').style.width = '-webkit-fill-available';
                });

                // Apply button
                document.getElementById('apply-svg-btn').addEventListener('click', () => {
                    const svgCode = svgInput.value.trim();

                    if (!svgCode) {
                        ErrorHandler.showToast('SVG code cannot be empty', 'error');
                        return;
                    }

                    // Basic validation
                    if (!svgCode.startsWith('<svg') || !svgCode.includes('</svg>')) {
                        ErrorHandler.showToast('Invalid SVG format', 'error');
                        return;
                    }

                    const previousState = JSON.parse(JSON.stringify(item));
                    item.svg = svgCode;

                    ChangeTracker.checkModifications(item);

                    if (!UndoRedoManager.isApplyingChange) {
                        UndoRedoManager.recordChange({
                            type: 'edit',
                            itemName: item.name,
                            previousState: previousState,
                            newState: JSON.parse(JSON.stringify(item))
                        });
                    }

                    UI.renderItems(true);
                    UI.renderShops();
                    ChangeTracker.updateHighlights();
                    ErrorHandler.showToast('SVG updated', 'success');
                });
            },
            async handleFileUpload(item, file, imgElement) {

                // Validate file
                if (!file.type.startsWith('image/')) {
                    ErrorHandler.showToast('Please select an image file', 'error');
                    return;
                }
                if (file.size > 10 * 1024 * 1024) { // 10MB limit
                    ErrorHandler.showToast('File size must be less than 10MB', 'error');
                    return;
                }
                // Create form data
                const formData = new FormData();
                formData.append('file', file);

                try {
                    // Upload to your Cloudflare Pages function
                    const response = await fetch('/api/upload', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`Upload failed: ${response.statusText}`);
                    }
                    const data = await response.json();

                    if (data.url !== item.img) {
                        const previousState = JSON.parse(JSON.stringify(item));
                        item.img = data.url;

                        ChangeTracker.checkModifications(item, item.name);  // Pass current name since it didn't change

                        if (!UndoRedoManager.isApplyingChange) {
                            UndoRedoManager.recordChange({
                                type: 'edit',
                                itemName: item.name,
                                previousState: previousState,
                                newState: JSON.parse(JSON.stringify(item))
                            });
                        }

                        if (data.url) {
                            imgElement.src = data.url;
                            imgElement.style.display = 'block';
                        } else {
                            imgElement.style.display = 'none';
                        }

                        UI.renderItems(true);
                        UI.renderShops();
                        ChangeTracker.updateHighlights();
                        ErrorHandler.showToast('Image updated', 'success');
                    }
                } catch (error) {
                    ErrorHandler.showToast('Upload failed: ' + error.message, 'error');
                }
            },



            close() {
                const modal = DOM.get('quick-editor-modal');
                modal.classList.remove('show');
                modal.classList.add('hidden');
                state.currentEditingItem = null;
                if (this.tagMenu) {
                    this.tagMenu.remove();
                    this.tagMenu = null;
                }

                // Clean up any editing states
                this.titleInput = null;
                this.imageInput = null;

                // Hide the panel
                DraggablePanelManager.hide();
            },

            setupButtons() {
                const descBtn = DOM.get('new-desc-btn');
                const gnBtn = DOM.get('new-gn-btn');
                const prcBtn = DOM.get('new-prc-btn');

                if (descBtn) descBtn.onclick = () => this.createDescItem('');
                if (gnBtn) gnBtn.onclick = () => {
                    const now = new Date();
                    const month = now.toLocaleDateString('en-US', { month: 'short' });
                    const year = now.toLocaleDateString('en-US', { year: 'numeric' });
                    this.createDescItem(`Gamenight (${month === "May" ? "May" : month + "."} ${year})`, true, true);
                };
                if (prcBtn) prcBtn.onclick = () => this.createPriceItem('');
            },

            setupDemandRating(item) {
                const demandButtons = document.querySelectorAll('.demand-rating-btn');
                const demandLabel = document.getElementById('demand-label');

                const demandLabels = {
                    5: 'Amazing',
                    4: 'Great',
                    3: 'Good',
                    2: 'Okay',
                    1: 'Bad',
                    0: 'Terrible'
                };

                const demandColors = {
                    5: '#90EE90',
                    4: '#ADD8E6',
                    3: '#FFD700',
                    2: '#FFA500',
                    1: '#FF6347',
                    0: '#CD5C5C'
                };

                // Initialize item demand if not set
                if (item.demand === undefined) {
                    item.demand = 0;
                }

                // Update UI based on current demand
                const updateDemandUI = (demand) => {
                    demandButtons.forEach(btn => {
                        const btnDemand = parseInt(btn.dataset.demand);
                        const color = demandColors[btnDemand];

                        if (btnDemand === demand) {
                            btn.style.background = color + '44';
                            btn.style.borderColor = color;
                            btn.style.color = color;
                            btn.style.fontWeight = '700';
                        } else {
                            btn.style.background = '#63636347';
                            btn.style.borderColor = '#6363637d';
                            btn.style.color = 'white';
                            btn.style.fontWeight = '400';
                        }
                    });

                    demandLabel.textContent = demandLabels[demand] || 'Not Set';
                    demandLabel.style.color = demandColors[demand] || '#666';
                };

                // Initial UI update
                updateDemandUI(item.demand);

                // Add click handlers
                demandButtons.forEach(btn => {
                    btn.onclick = () => {
                        const previousState = JSON.parse(JSON.stringify(state.currentEditingItem));
                        const newDemand = parseInt(btn.dataset.demand);
                        state.currentEditingItem.demand = newDemand;

                        updateDemandUI(newDemand);

                        ChangeTracker.checkModifications(state.currentEditingItem);

                        if (!UndoRedoManager.isApplyingChange && previousState.demand !== newDemand) {
                            UndoRedoManager.recordChange({
                                type: 'edit',
                                itemName: state.currentEditingItem.name,
                                previousState: previousState,
                                newState: JSON.parse(JSON.stringify(state.currentEditingItem))
                            });
                        }

                        UI.renderItems(true);
                        UI.renderShops();
                        ChangeTracker.updateHighlights();
                    };
                });
            },

            renderTags(item) {
                const flagRow = DOM.query('.flag-row');

                // Build tags array from item properties
                const tags = Object.entries({
                    New: item.new,
                    Weekly: item.weekly,
                    Star: item.weeklystar,
                    Retired: item.retired,
                    Premium: item.premium,
                    Untradable: !item.tradable,
                    Removed: item.removed
                }).filter(([k, v]) => v).map(([k]) => k);

                // Store tags in closure for tag management
                this.currentTags = tags;

                // Clear existing tags and buttons
                flagRow.querySelectorAll('.tag-pill, .small-btn.ghost').forEach(e => e.remove());

                // Add tag selector button
                const btn = document.createElement('button');
                btn.className = 'small-btn ghost';
                btn.textContent = 'Tags';
                btn.style.cssText = 'margin: 10px 47%;display: block;font-variant:all-petite-caps;';
                btn.onclick = e => {
                    e.stopPropagation();
                    if (this.tagMenu) {
                        this.tagMenu.remove();
                        this.tagMenu = null;
                        return;
                    }

                    this.openTagSelector(flagRow);

                };
                flagRow.appendChild(btn);

                this.renderTagPills(flagRow);
            },

            renderTagPills(flagRow) {
                // Clear existing tag pills first (but not the Tags button)
                flagRow.querySelectorAll('.tag-pill').forEach(e => e.remove());

                this.currentTags.forEach(tag => {
                    const pill = document.createElement('span');
                    pill.className = 'tag-pill';
                    pill.textContent = tag;

                    const color = this.TAG_COLORS[tag] || '#aaa';
                    pill.style.cssText = `border-color:${color};background:${color}33;color:${color}`;

                    const closeBtn = document.createElement('span');
                    closeBtn.textContent = ' Ã—';
                    closeBtn.style.cssText = 'cursor:pointer;-webkit-text-stroke-width:medium';
                    closeBtn.onclick = () => {
                        this.currentTags = this.currentTags.filter(t => t !== tag);

                        const previousState = JSON.parse(JSON.stringify(state.currentEditingItem));
                        // Update item properties
                        if (tag === "Untradable") {
                            state.currentEditingItem.tradable = true;
                        } else {
                            state.currentEditingItem[this.TAG_TO_PROP[tag]] = false;
                        }

                        ChangeTracker.checkModifications(state.currentEditingItem);

                        if (!UndoRedoManager.isApplyingChange &&
                            previousState[this.TAG_TO_PROP[tag]] !== state.currentEditingItem[this.TAG_TO_PROP[tag]]) {

                            UndoRedoManager.recordChange({
                                type: 'edit',
                                itemName: state.currentEditingItem.name,
                                previousState: previousState,
                                newState: JSON.parse(JSON.stringify(state.currentEditingItem))
                            });
                        }
                        UI.renderItems(true);
                        this.renderTagPills(flagRow);
                        UI.renderShops();
                        ChangeTracker.updateHighlights();
                    };

                    pill.appendChild(closeBtn);
                    flagRow.appendChild(pill);
                });
            },

            openTagSelector(flagRow) {
                //wait 1ms

                if (this.tagMenu) {
                    this.tagMenu.remove();
                }

                this.tagMenu = document.createElement('div');
                this.tagMenu.style.cssText = 'position:absolute;background:#1e293b;padding:10px;border:1px solid #555;border-radius:8px;z-index:1000;transform: translateY(48px);';

                Object.keys(this.TAG_COLORS).forEach(tag => {
                    const btn = document.createElement('button');
                    btn.textContent = tag;
                    btn.className = 'tag-option';

                    if (this.currentTags.includes(tag)) {
                        btn.style.cssText = `background:${this.TAG_COLORS[tag]}36;color:#5c5c5c`;
                    }

                    btn.onclick = () => {
                        const previousState = JSON.parse(JSON.stringify(state.currentEditingItem));
                        if (!this.currentTags.includes(tag)) {
                            this.currentTags.push(tag);

                            // Update item properties
                            if (tag === "Untradable") {
                                state.currentEditingItem.tradable = false;
                            } else {
                                state.currentEditingItem[this.TAG_TO_PROP[tag]] = true;
                            }
                        }

                        ChangeTracker.checkModifications(state.currentEditingItem);

                        if (!UndoRedoManager.isApplyingChange &&
                            previousState[this.TAG_TO_PROP[tag]] !== state.currentEditingItem[this.TAG_TO_PROP[tag]]) {

                            UndoRedoManager.recordChange({
                                type: 'edit',
                                itemName: state.currentEditingItem.name,
                                previousState: previousState,
                                newState: JSON.parse(JSON.stringify(state.currentEditingItem))
                            });
                        }

                        this.tagMenu.remove();
                        this.tagMenu = null;
                        this.renderTagPills(flagRow);

                        UI.renderItems(true);
                        UI.renderShops();
                        ChangeTracker.updateHighlights();
                    };

                    this.tagMenu.appendChild(btn);
                });

                flagRow.appendChild(this.tagMenu);
            },

            setupModalClickHandler(modalContent) {
                modalContent.addEventListener('click', e => {
                    // Handle tag menu
                    if (this.tagMenu &&
                        !this.tagMenu.contains(e.target) &&
                        !e.target.classList.contains('tag-option') &&
                        e.target.textContent !== 'Tags') {
                        this.tagMenu.remove();
                        this.tagMenu = null;
                    }

                    // Handle title input - restore title if clicking away
                    if (this.titleInput && !this.titleInput.contains(e.target)) {
                        const saveName = () => {
                            const newName = this.titleInput.value.trim();
                            if (newName && newName !== state.currentEditingItem.name) {
                                state.currentEditingItem.name = newName;
                                ChangeTracker.checkChanges(state.currentEditingItem);

                                UI.renderItems(true);
                                UI.renderShops();
                                ChangeTracker.updateHighlights();
                            }

                            DOM.get('quick-editor-title').innerHTML = state.currentEditingItem.name + `<span class="icon" style="..."></span>`;
                            this.titleInput = null;
                        };
                        saveName();
                    }
                });
            },

            renderDescriptions(item) {
                const container = DOM.query('.desc-list');
                container.innerHTML = '';

                const descriptions = (item.from || '').split('<br>').map(x => x.trim()).filter(Boolean);
                descriptions.forEach(desc => {
                    const isGamenight = /\([A-Z][a-z]{2}\./.test(desc);
                    this.createDescItem(desc, isGamenight);
                });

                // Initialize Sortable
                if (!isTouch) {
                    Sortable.create(container, {
                        animation: 150,
                        handle: '.desc-item',
                        group: { name: 'desc', pull: false, put: false },
                        sort: true,
                        filter: '.editing, input, button',  // â† ADD 'input, button'
                        preventOnFilter: false,  // â† ADD THIS
                        onStart: function (evt) {
                            // Prevent dragging if clicking on input
                            if (evt.originalEvent.target.tagName === 'INPUT' ||
                                evt.originalEvent.target.tagName === 'BUTTON') {
                                return false;
                            }
                        }
                    });
                }
            },

            renderPrices(item) {
                const container = DOM.query('.prc-list');
                container.innerHTML = '';

                const prices = (item['price/code/rarity'] || '').split('<br>').map(x => x.trim()).filter(Boolean);
                prices.forEach(price => this.createPriceItem(price));

                // Initialize Sortable
                if (!isTouch) {
                    Sortable.create(container, {
                        animation: 150,
                        handle: '.prc-item',
                        group: { name: 'prc', pull: false, put: false },
                        sort: true,
                        filter: '.editing, input, button',  // â† ADD 'input, button'
                        preventOnFilter: false,  // â† ADD THIS
                        onStart: function (evt) {
                            // Prevent dragging if clicking on input
                            if (evt.originalEvent.target.tagName === 'INPUT' ||
                                evt.originalEvent.target.tagName === 'BUTTON') {
                                return false;
                            }
                        }
                    });
                }
            },

            createDescItem(value = '', isGamenight = false, focus = false) {
                const container = DOM.query('.desc-list');
                const months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'];
                const selectedMonths = new Set();

                // Replace the isOriginal check with:
                const isOriginal = !ChangeTracker.isNewItem(state.currentEditingItem.name) &&
                    ChangeTracker.isValueOriginal(state.currentEditingItem, 'from', value);

                const li = this.createElement('li', {
                    className: 'desc-item'
                });

                // Apply original styling if this content existed in the original item
                if (!isOriginal) {
                    li.style.background = '#5c5c5c';
                    li.style.border = 'none';
                }

                // ... rest of the method remains the same
                const label = this.createElement('span', {
                    style: 'flex: 1 1;flex-grow:1;overflow:hidden;white-space:nowrap;text-overflow:ellipsis',
                    textContent: value || ''
                });

                const input = this.createElement('input', {
                    type: 'text',
                    value: value || '',
                });


                input.addEventListener('mousedown', (e) => e.stopPropagation());
                input.addEventListener('click', (e) => e.stopPropagation());
                input.addEventListener('pointerdown', (e) => e.stopPropagation());

                const monthsWrapper = this.createElement('div', {
                    style: 'cursor:initial;justify-content:space-evenly;display:none;flex-wrap:wrap;gap:4px;flex-grow:1'
                });

                const yearInput = this.createElement('input', {
                    type: 'number',
                    min: 2016,
                    max: new Date().getFullYear(),
                    placeholder: 'Year',
                    style: 'background: #3a3a3a;font-weight:700;font-size:14px;width:50px;display:none;border:none;border-radius:4px;padding:4px 6px'
                });

                yearInput.addEventListener('mousedown', (e) => e.stopPropagation());
                yearInput.addEventListener('click', (e) => e.stopPropagation());
                yearInput.addEventListener('pointerdown', (e) => e.stopPropagation());

                const quantityInput = this.createElement('input', {
                    type: 'number',
                    min: 1,
                    max: 99,
                    value: 1,
                    placeholder: 'x',
                    title: 'Quantity',
                    style: 'background: #3a3a3a;font-weight:700;font-size:14px;width:40px;display:none;border:none;border-radius:4px;padding:4px 6px;margin-right:8px'
                });

                quantityInput.addEventListener('mousedown', (e) => e.stopPropagation());
                quantityInput.addEventListener('click', (e) => e.stopPropagation());
                quantityInput.addEventListener('pointerdown', (e) => e.stopPropagation());

                // Create month buttons
                months.forEach(month => {
                    const btn = this.createElement('span', {
                        textContent: month,
                        style: 'padding:4px 8px;border-radius:4px;background:#777;cursor:pointer;user-select:none;transition:all .15s'
                    });

                    btn.onclick = () => {
                        if (selectedMonths.has(month)) {
                            selectedMonths.delete(month);
                            btn.style.background = '#777';
                        } else {
                            selectedMonths.add(month);
                            btn.style.background = 'var(--accent)';
                        }
                        btn.style.transform = 'scale(1.05)';
                        setTimeout(() => btn.style.transform = '', 100);
                    };

                    monthsWrapper.appendChild(btn);
                });

                const editBtn = this.createIconButton('edit', 'á´‡á´…Éªá´›', 'small-btn ghost');
                const deleteBtn = this.createIconButton('delete', '', 'small-btn danger', 'padding:6px 0px 6px 6px;');
                const okBtn = this.createIconButton('check', '', 'small-btn success', 'padding:6px 0px 6px 6px;text-shadow:0 0 5px #00000057;display:none;font-weight:700');

                // Parse existing gamenight data
                if (isGamenight && /\(.+\)/.test(value)) {
                    // Parse quantity if present (e.g., "x2 Gamenight (Mar. 2025)")
                    const quantityMatch = value.match(/^x(\d+)\s+/);
                    const quantity = quantityMatch ? parseInt(quantityMatch[1]) : 1;
                    quantityInput.value = quantity;

                    const match = value.match(/\((.+)\s(\d{4})\)/);
                    if (match) {
                        const [_, monthsStr, year] = match;
                        monthsStr.split(',').map(m => m.trim()).forEach(m => {
                            selectedMonths.add(m);
                            [...monthsWrapper.children].forEach(btn => {
                                if (btn.textContent === m) {
                                    btn.style.background = 'var(--accent)';
                                }
                            });
                        });
                        yearInput.value = year || '';
                    }
                }

                // Setup edit/done functions with dynamic original check
                const edit = () => {
                    li.classList.add('editing');
                    li.setAttribute('data-draggable', 'false');  // â† ADD THIS
                    deleteBtn.style.display = 'none';
                    okBtn.style.display = 'inline-block';
                    label.style.display = 'none';
                    editBtn.style.display = 'none';
                    li.style.background = '#5c5c5c';
                    li.style.border = 'none'; // Remove original border when editing

                    if (isGamenight) {
                        monthsWrapper.style.display = 'flex';
                        yearInput.style.display = 'inline-block';
                        quantityInput.style.display = 'inline-block';
                    } else {
                        input.style.display = 'inline-block';
                        setTimeout(() => input.focus(), 100);
                    }
                };

                if (value.trim() === '') { edit(); }
                if (focus) { edit(); }

                const done = () => {
                    if (!li.classList.contains('editing')) return;
                    li.classList.remove('editing');
                    li.removeAttribute('data-draggable');  // â† ADD THIS
                    deleteBtn.style.display = 'inline-block';
                    okBtn.style.display = 'none';

                    if (isGamenight) {
                        const qty = parseInt(quantityInput.value) || 1;
                        const prefix = qty > 1 ? `x${qty} ` : '';
                        value = `${prefix}Gamenight (${[...selectedMonths].join(', ')}${yearInput.value ? ' ' + yearInput.value : ''})`;
                    } else {
                        value = input.value.trim();
                        if (!value) {
                            li.remove();
                            return;
                        }
                    }

                    label.textContent = value;
                    label.style.display = 'inline';
                    input.style.display = 'none';
                    monthsWrapper.style.display = 'none';
                    yearInput.style.display = 'none';
                    quantityInput.style.display = 'none';
                    editBtn.style.display = 'inline-block';

                    // Re-check if the new value is original after editing
                    const newIsOriginal = state.currentEditingItem &&
                        value &&
                        ChangeTracker.isValueOriginal(state.currentEditingItem, 'from', value);

                    if (newIsOriginal) {
                        li.style.background = '#3c3c3c';
                        li.style.border = '1px solid #555';
                    } else {
                        li.style.background = '#5c5c5c';
                        li.style.border = 'none';
                    }

                    this.updateItemDescriptions();
                };

                // Setup event handlers
                editBtn.onclick = e => { e.stopPropagation(); edit(); };
                li.ondblclick = edit;
                input.onblur = done;
                input.onkeydown = e => { if (e.key === 'Enter' || e.key === 'Escape') done(); };
                deleteBtn.onclick = () => {
                    li.remove();
                    this.updateItemDescriptions();
                };
                okBtn.onclick = done;

                // Setup drag handlers
                this.setupDragHandlers(li);

                // Append elements
                if (isGamenight) {
                    monthsWrapper.append(quantityInput, yearInput, okBtn);
                    li.append(label, input, monthsWrapper, editBtn, deleteBtn);
                } else {
                    li.append(label, input, yearInput, monthsWrapper, editBtn, deleteBtn, okBtn);
                }

                container.appendChild(li);
            },

            createPriceItem(value = '') {
                const container = DOM.query('.prc-list');

                // Replace the isOriginal check with:
                const isOriginal = !ChangeTracker.isNewItem(state.currentEditingItem.name) &&
                    ChangeTracker.isValueOriginal(state.currentEditingItem, 'price/code/rarity', value);



                const li = this.createElement('li', {
                    className: 'prc-item'
                });

                // Apply original styling if this content existed in the original item
                if (!isOriginal) {
                    li.style.background = '#5c5c5c';
                    li.style.border = 'none';
                }

                const icon = this.createElement('img', {
                    src: './imgs/trs.png',
                    style: 'display:inline-block;width:20px;height:20px;margin-right:6px;vertical-align:middle'
                });

                const label = this.createElement('span', {
                    className: 'prc-label',
                    textContent: value || ''
                });

                const input = this.createElement('input', {
                    type: 'text',
                    value: value || '',
                });

                input.addEventListener('mousedown', (e) => e.stopPropagation());
                input.addEventListener('click', (e) => e.stopPropagation());
                input.addEventListener('pointerdown', (e) => e.stopPropagation());

                const formatLabel = () => {
                    const text = input.value.trim();

                    // Reset styles
                    icon.style.display = 'inline-block';
                    icon.src = './imgs/trs.png';
                    label.style.color = '';
                    label.style.textShadow = '';
                    label.style.fontSize = '';
                    label.style.fontVariant = '';
                    label.style.fontFamily = '';
                    // Apply special formatting
                    if (text.includes("Tokens")) {
                        label.style.fontWeight = '500';
                        label.style.webkitTextStroke = '1px rgb(255, 83, 219)';
                    }
                    if (text.includes("Robux")) {
                        label.style.fontWeight = '700';
                    }
                    if (text.includes("%")) {
                        label.style.color = 'rgb(193 68 255)';
                        label.style.fontWeight = '500';
                        label.style.textShadow = '0 0 6px rgb(199 0 255)';
                    } else if (text.includes("[EXPIRED]")) {
                        label.style.fontFamily = 'inconsolata';
                        label.style.fontWeight = 'bold';
                        label.style.color = 'red';
                    } else if (text.includes("[ACTIVE]")) {
                        label.style.fontFamily = 'inconsolata';
                        label.style.color = 'rgb(251 255 68)';
                    } else if (text.includes("Unobtainable")) {
                        icon.src = './imgs/Red_x.png';
                        label.style.color = 'rgb(255 44 44)';
                    }

                    // Update icon based on currency type
                    for (const [key, src] of Object.entries(this.ICON_MAP)) {
                        if (text.toLowerCase().includes(key.toLowerCase())) {
                            label.textContent = text.toLowerCase().replace(` ${key.toLowerCase()}`, "");
                            icon.src = src;
                            break;
                        }
                    }

                    // Hide icon if default
                    if (icon.src.includes('trs.png')) {
                        icon.style.display = 'none';
                    }
                };

                const editBtn = this.createIconButton('edit', 'á´‡á´…Éªá´›', 'small-btn ghost');
                const deleteBtn = this.createIconButton('delete', '', 'small-btn danger', 'padding:6px 0px 6px 6px;');
                const okBtn = this.createIconButton('check', '', 'small-btn success', 'padding:6px 0px 6px 6px;text-shadow:0 0 5px #00000057;display:none;font-weight:700');

                // Initial format
                formatLabel();

                // Setup edit/done functions with dynamic original check
                const edit = () => {
                    deleteBtn.style.display = 'none';
                    li.setAttribute('data-draggable', 'false');  // â† ADD THIS
                    okBtn.style.display = 'inline-block';
                    label.style.display = 'none';
                    editBtn.style.display = 'none';
                    input.style.display = 'inline-block';
                    li.classList.add('editing');
                    li.style.background = '#5c5c5c';
                    li.style.border = 'none'; // Remove original border when editing
                    setTimeout(() => input.focus(), 100);
                };

                if (value.trim() === '') { edit(); }

                const done = () => {
                    if (!li.classList.contains('editing')) return;
                    li.classList.remove('editing');
                    li.removeAttribute('data-draggable');  // â† ADD THIS
                    deleteBtn.style.display = 'inline-block';
                    okBtn.style.display = 'none';

                    const newValue = input.value.trim();
                    if (!newValue) {
                        li.remove();
                        this.updateItemPrices();
                        return;
                    }

                    label.textContent = newValue;
                    label.style.display = 'inline';
                    input.style.display = 'none';
                    editBtn.style.display = 'inline-block';
                    formatLabel();

                    // Re-check if the new value is original after editing
                    const newIsOriginal = state.currentEditingItem &&
                        newValue &&
                        ChangeTracker.isValueOriginal(state.currentEditingItem, 'price/code/rarity', newValue);

                    if (newIsOriginal) {
                        li.style.background = '#3c3c3c';
                        li.style.border = '1px solid #555';
                    } else {
                        li.style.background = '#5c5c5c';
                        li.style.border = 'none';
                    }

                    this.updateItemPrices();
                };

                // Setup event handlers
                input.oninput = formatLabel;
                editBtn.onclick = e => { e.stopPropagation(); edit(); };
                li.ondblclick = edit;
                input.onblur = done;
                input.onkeydown = e => { if (e.key === 'Enter' || e.key === 'Escape') done(); };
                deleteBtn.onclick = () => {
                    li.remove();
                    this.updateItemPrices();
                };
                okBtn.onclick = done;

                // Setup drag handlers
                this.setupDragHandlers(li);

                // Append elements
                li.append(icon, label, input, editBtn, deleteBtn, okBtn);
                container.appendChild(li);
            },

            updateItemDescriptions() {
                const items = Array.from(DOM.queryAll('.desc-item > span'))
                    .map(span => span.textContent.trim())
                    .filter(v => v && v !== 'Description...');

                const previousState = JSON.parse(JSON.stringify(state.currentEditingItem));
                state.currentEditingItem.from = items.join('<br>') || '';

                // Check for modifications
                ChangeTracker.checkModifications(state.currentEditingItem);

                // Record change for undo if not already applying
                if (!UndoRedoManager.isApplyingChange &&
                    previousState.from !== state.currentEditingItem.from) {
                    UndoRedoManager.recordChange({
                        type: 'edit',
                        itemName: state.currentEditingItem.name,
                        previousState: previousState,
                        newState: JSON.parse(JSON.stringify(state.currentEditingItem))
                    });
                }

                ChangeTracker.updateHighlights();

                // Trigger overflow check after content update
                if (DraggablePanelManager.state.isInitialized) {
                    DraggablePanelManager.refreshOverflow();
                }
            },

            updateItemPrices() {
                const items = Array.from(DOM.queryAll('.prc-item input'))
                    .map(input => input.value.trim())
                    .filter(v => v);

                const previousState = JSON.parse(JSON.stringify(state.currentEditingItem));
                state.currentEditingItem['price/code/rarity'] = items.join('<br>') || '';

                // Check for modifications
                ChangeTracker.checkModifications(state.currentEditingItem);

                // Record change for undo if not already applying
                if (!UndoRedoManager.isApplyingChange &&
                    previousState['price/code/rarity'] !== state.currentEditingItem['price/code/rarity']) {
                    UndoRedoManager.recordChange({
                        type: 'edit',
                        itemName: state.currentEditingItem.name,
                        previousState: previousState,
                        newState: JSON.parse(JSON.stringify(state.currentEditingItem))
                    });
                }

                ChangeTracker.updateHighlights();

                // Trigger overflow check after content update
                if (DraggablePanelManager.state.isInitialized) {
                    DraggablePanelManager.refreshOverflow();
                }
            },

            setupDragHandlers(element) {
                element.ondragstart = e => {
                    e.dataTransfer.setData('text/plain', state.currentEditingItem.name);
                    e.dataTransfer.effectAllowed = 'move';
                    if (typeof dragImgEl !== 'undefined') {
                        e.dataTransfer.setDragImage(dragImgEl, 0, 0);
                    }
                    element.style.opacity = '0.5';
                };

                element.ondragend = () => {
                    element.style.opacity = '1';
                };
            },

            createElement(tag, props = {}) {
                const el = document.createElement(tag);
                Object.assign(el, props);
                return el;
            },

            createIconButton(type, text = '', className = '', additionalStyle = '') {
                const icons = {
                    edit: 'M16.293 3.293a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1 0 1.414l-9 9A1 1 0 0 1 11 17H8a1 1 0 0 1-1-1v-3a1 1 0 0 1 .293-.707l9-9zM9 13.414V15h1.586l8-8L17 5.414l-8 8zM3 7a2 2 0 0 1 2-2h5a1 1 0 1 1 0 2H5v12h12v-5a1 1 0 1 1 2 0v5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z',
                    delete: 'M7 4a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2h4a1 1 0 1 1 0 2h-1.069l-.867 12.142A2 2 0 0 1 17.069 22H6.93a2 2 0 0 1-1.995-1.858L4.07 8H3a1 1 0 0 1 0-2h4V4zm2 2h6V4H9v2zM6.074 8l.857 12H17.07l.857-12H6.074zM10 10a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-6a1 1 0 0 1 1-1zm4 0a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-6a1 1 0 0 1 1-1z',
                    check: 'M61.07,12.9,57,8.84a2.93,2.93,0,0,0-4.21,0L28.91,32.73,19.2,23A3,3,0,0,0,15,23l-4.06,4.07a2.93,2.93,0,0,0,0,4.21L26.81,47.16a2.84,2.84,0,0,0,2.1.89A2.87,2.87,0,0,0,31,47.16l30.05-30a2.93,2.93,0,0,0,0-4.21Z'
                };

                const btn = this.createElement('button', {
                    className: className,
                    innerHTML: `<div class="icon"></div>${text}`
                });

                if (icons[type]) {
                    btn.querySelector('.icon').style.maskImage = `url('data:image/svg+xml,<svg viewBox="${type === 'check' ? '0 -8 72 72' : '0 0 24 24'}" xmlns="http://www.w3.org/2000/svg"><path d="${icons[type]}" /></svg>')`;
                    if (type == 'edit') {
                        btn.querySelector('.icon').style.marginRight = '3px';
                    }
                }

                if (additionalStyle) {
                    btn.style.cssText = additionalStyle
                }

                return btn;
            }
        };

        // ============================
        // History Manager
        // ============================
        const HistoryManager = {
            // Configuration constants
            ICONS: {
                true: '<span class="typeicon green">âœ“</span>',
                false: '<span class="typeicon red">âœ—</span>',
                price: '<span class="typeicon price">$</span>',
                added: '<span style="font-family: \'Segoe UI Symbol\', sans-serif;" class="typeicon green">âž•</span>',
                removed: '<span style="font-family: \'Segoe UI Symbol\', sans-serif;" class="typeicon red">âž–</span>'
            },

            BOOLEAN_FIELDS: ['weeklystar', 'weekly', 'new', 'retired', 'premium', 'tradable', 'removed'],

            SECTION_CONFIG: [
                ['Added Items', 'added'],
                ['Removed Items', 'removed'],
                ['Star Shop', 'weeklystar'],
                ['Weekly', 'weekly'],
                ['New', 'new'],
                ['Retired', 'retired'],
                ['Removed', 'removed'],
                ['Premium', 'premium'],
                ['Tradable', 'tradable'],
                ['Demand', 'demand'],
                ['Icon', 'img'],
                ['Text', 'svg'],
                ['RAP', 'price'],
                ['Description', 'from'],
                ['Price/Code/Rarity', 'price/code/rarity']
            ],

            // Pagination settings
            MAX_ENTRIES_PER_PAGE: 3,
            ENTRY_HEIGHT_THRESHOLD: 400,
            currentPage: 0,
            historyData: [],
            isAnimating: false,

            async load() {
                const container = DOM.get('history-list');
                UI.showLoading(container);

                try {
                    this.historyData = await API.loadHistory();
                    if (!Array.isArray(this.historyData) || this.historyData.length === 0) {
                        container.innerHTML = '<p>No history available.</p>';
                        return;
                    }

                    this.currentPage = 0;
                    this.renderPage(container, 'none');
                } catch (error) {
                    UI.showError(container, 'Failed to load history');
                }
            },

            renderPage(container, direction = 'none') {
                let wrapper = container.querySelector('.history-wrapper');
                if (!wrapper) {
                    wrapper = Utils.createElement('div', {
                        className: 'history-wrapper',
                        style: { position: 'relative', overflowX: 'hidden', overflowY: 'scroll', height: '400px' }
                    });
                    torn = Utils.createElement('div', {
                        className: 'torn-edge'
                    });
                    container.innerHTML = '';
                    container.appendChild(wrapper);
                    container.appendChild(torn);
                }

                const newInner = Utils.createElement('div', {
                    className: 'history-inner',
                    style: { position: 'absolute', width: '97%', top: '0', transition: 'transform 0.3s ease-in-out' }
                });

                this.historyData.forEach(entry => this.renderEntry(entry, newInner));

                wrapper.appendChild(newInner);
            },

            addPaginationControls(wrapper) {
                const totalPages = Math.ceil(this.historyData.length / this.MAX_ENTRIES_PER_PAGE);
                const controls = Utils.createElement('div', {
                    className: 'pagination-controls',
                    style: { position: 'absolute', bottom: '10px', right: '10px', display: 'flex', flexDirection: 'column', alignItems: 'center' }
                });

                const upBtn = Utils.createElement('button', {
                    className: `small-btn ghost ${this.currentPage === 0 || this.isAnimating ? 'disabled' : ''}`,
                    innerHTML: 'â†‘',
                    onClick: () => {
                        if (this.currentPage > 0 && !this.isAnimating) {
                            this.currentPage--;
                        }
                    }
                });

                const pageIndicator = Utils.createElement('span', {
                    textContent: `${this.currentPage + 1}/${totalPages}`,
                    style: { margin: '5px 0', fontSize: '12px', color: '#fff', textShadow: 'rgb(0, 0, 0) 1px 1px, rgb(0, 0, 0) 1px -1px, rgb(0, 0, 0) -1px 1px, rgb(0, 0, 0) -1px -1px, rgb(0, 0, 0) 0px -2px, rgb(0, 0, 0) 0px 1px' }
                });

                const downBtn = Utils.createElement('button', {
                    className: `small-btn ghost ${this.currentPage >= totalPages - 1 || this.isAnimating ? 'disabled' : ''}`,
                    innerHTML: 'â†“',
                    onClick: () => {
                        if (this.currentPage < totalPages - 1 && !this.isAnimating) {
                            this.currentPage++;
                        }
                    }
                });

                if (this.currentPage === 0) {
                    upBtn.style.opacity = '0.5';
                }

                if (this.currentPage === totalPages - 1) {
                    downBtn.style.opacity = '0.5';
                }

                controls.appendChild(upBtn);
                controls.appendChild(pageIndicator);
                controls.appendChild(downBtn);
                wrapper.parentElement.appendChild(controls);
            },

            formatTime(timestamp) {
                const ts = new Date(timestamp);
                const now = new Date();
                const yesterday = new Date();
                yesterday.setDate(now.getDate() - 1);

                const isToday = ts.toDateString() === now.toDateString();
                const isYesterday = ts.toDateString() === yesterday.toDateString();

                if (!isToday && !isYesterday) {
                    return ts.toLocaleString();
                }

                let hours = ts.getHours();
                const minutes = ts.getMinutes().toString().padStart(2, '0');
                const seconds = ts.getSeconds().toString().padStart(2, '0');
                const ampm = hours >= 12 ? 'PM' : 'AM';
                hours = hours % 12 || 12;

                const formattedTime = `${hours}:${minutes}:${seconds} ${ampm}`;
                return `${isToday ? 'Today' : 'Yesterday'}, ${formattedTime}`;
            },

            parseValue(value) {
                return (!value || value === 'undefined' || value === '') ? undefined : value;
            },

            parsePrice(value) {
                return (!value || value === 'undefined') ? "0" : value;
            },

            processBooleanChange(item, newVal) {
                return { item, value: newVal === 'true' };
            },

            processPriceChange(item, oldRaw, newRaw) {
                return {
                    item,
                    oldPrice: this.parsePrice(oldRaw),
                    newPrice: this.parsePrice(newRaw)
                };
            },

            processDemandChange(item, oldRaw, newRaw) {
                return {
                    item,
                    oldDemand: parseInt(oldRaw) || 0,
                    newDemand: parseInt(newRaw) || 0
                };
            },

            processDescriptionChange(item, oldVal, newVal) {
                return { item, oldDesc: oldVal, newDesc: newVal };
            },

            formatBooleanItem(item) {
                return `${this.ICONS[item.value]} <strong>[${item.item}]</strong>`;
            },

            formatPriceItem(item) {
                return `${this.ICONS.price} <strong>[${item.item}]</strong> <span class="old strike">${item.oldPrice}</span> â†’ <span class="new">${item.newPrice}</span>`;
            },

            formatDemandItem(item) {
                const labels = ['Terrible', 'Bad', 'Okay', 'Good', 'Great', 'Amazing'];
                const oldDemand = item.oldDemand || 0;
                const newDemand = item.newDemand || 0;
                const oldLabel = labels[oldDemand];
                const newLabel = labels[newDemand];
                const starIcon = '<span class="typeicon" style="color: #ffd700;">â˜…</span>';
                return `${starIcon} <strong>[${item.item}]</strong> <span class="old strike">${oldLabel} (${oldDemand}â˜…)</span> â†’ <span class="new">${newLabel} (${newDemand}â˜…)</span>`;
            },

            formatDescriptionItem(item) {
                const oldLines = (item.oldDesc || "").split(/<br>|\n/).map(s => s.trim()).filter(Boolean);
                const newLines = (item.newDesc || "").split(/<br>|\n/).map(s => s.trim()).filter(Boolean);
                const maxLines = Math.max(oldLines.length, newLines.length);

                let output = `<strong>[${item.item}]</strong><br>`;

                for (let i = 0; i < maxLines; i++) {
                    const oldLine = oldLines[i];
                    const newLine = newLines[i];

                    if (oldLine === newLine) {
                        output += `&nbsp;&nbsp;â¨½&nbsp;${oldLine}<br>`;
                    } else if (oldLine && newLine) {
                        output += `&nbsp;&nbsp;â¨½&nbsp;<span class="amber">${oldLine}</span> â†’ <span class="amber">${newLine}</span><br>`;
                    } else if (oldLine && !newLine) {
                        output += `&nbsp;&nbsp;â¨½&nbsp;<span class="old">${oldLine} ðŸ—™</span><br>`;
                    } else if (!oldLine && newLine) {
                        output += `&nbsp;&nbsp;â¨½&nbsp;<span class="new">${newLine} +</span><br>`;
                    }
                }

                return output;
            },

            formatImageItem(item) {
                const getFilename = (url) => {
                    if (!url) return 'none';
                    const parts = url.split('/');
                    return parts[parts.length - 1];
                };

                const oldFile = getFilename(item.oldImg);
                const newFile = getFilename(item.newImg);

                // If filename is the same, it's just a domain change
                if (oldFile === newFile) {
                    const oldDomain = item.oldImg.split('/')[2] || 'old source';
                    const newDomain = item.newImg.split('/')[2] || 'new source';
                    return `<strong>[${item.item}]</strong> moved: ${oldDomain} â†’ ${newDomain}`;
                }

                return `<strong>[${item.item}]</strong> <span class="old">${oldFile}</span> â†’ <span class="new">${newFile}</span>`;
            },

            formatAddedItem(item) {
                return `${this.ICONS.added} <strong>${item.name}</strong>`;
            },

            formatRemovedItem(item) {
                return `${this.ICONS.removed} <strong>${item.name}</strong>`;
            },

            processChanges(diffLines) {
                const changes = Object.fromEntries([
                    ['added', []],
                    ['removed', []],
                    ...this.BOOLEAN_FIELDS.map(field => [field, []]),
                    ['price', []],
                    ['demand', []],
                    ['from', []],
                    ['price/code/rarity', []],
                    ['img', []],
                    ['svg', []]
                ]);

                for (const line of diffLines) {
                    // Check for added items
                    const addedMatch = line.match(/^ðŸ†•\s+Added:\s+"([^"]+)"$/);
                    if (addedMatch) {
                        changes.added.push({ name: addedMatch[1] });
                        continue;
                    }

                    // Check for removed items
                    const removedMatch = line.match(/^âŒ\s+Removed:\s+"([^"]+)"$/);
                    if (removedMatch) {
                        changes.removed.push({ name: removedMatch[1] });
                        continue;
                    }

                    // Check for regular changes
                    const match = line.match(/^\[(.+?)\] ([\w\/]+): (.*) â†’ (.*)$/);
                    if (!match) continue;

                    const [, item, fieldRaw, oldRaw, newRaw] = match;
                    const field = fieldRaw.toLowerCase();
                    const oldVal = this.parseValue(oldRaw);
                    const newVal = this.parseValue(newRaw);

                    if (this.BOOLEAN_FIELDS.includes(field) && (newRaw === 'true' || newRaw === 'false')) {
                        changes[field].push(this.processBooleanChange(item, newRaw));
                    } else if (field === 'price') {
                        changes.price.push(this.processPriceChange(item, oldRaw, newRaw));
                    } else if (field === 'demand') {
                        changes.demand.push(this.processDemandChange(item, oldRaw, newRaw));
                    } else if (field === 'from') {
                        changes.from.push(this.processDescriptionChange(item, oldVal, newVal));
                    } else if (field === 'price/code/rarity') {
                        changes['price/code/rarity'].push(this.processDescriptionChange(item, oldVal, newVal));
                    } else if (field === 'img') {  // ADD THIS
                        changes.img.push({ item, oldImg: oldRaw, newImg: newRaw });
                    } else if (field === 'svg') {  // ADD THIS
                        changes.svg.push({ item, oldImg: oldRaw, newImg: newRaw });
                    }
                }

                return changes;
            },

            createSection(title, items, formatterMethod) {
                if (!items.length) return null;

                const section = Utils.createElement('div', {
                    className: 'history-section'
                });

                const titleElement = Utils.createElement('h4', {
                    textContent: title,
                    className: 'section-title'
                });
                section.appendChild(titleElement);

                const list = Utils.createElement('ul', {
                    className: 'history-list'
                });

                items.forEach(item => {
                    const listItem = Utils.createElement('li', {
                        className: (title === 'Description' || title === 'Price/Code/Rarity') ? 'description-item' : 'list-item',
                        innerHTML: formatterMethod.call(this, item)
                    });
                    list.appendChild(listItem);
                });

                section.appendChild(list);
                return section;
            },

            renderEntry(entry, container) {
                const header = Utils.createElement('div', {
                    textContent: entry.username.toUpperCase(),
                    className: 'history-header'
                });

                const timeDiv = Utils.createElement('div', {
                    textContent: this.formatTime(entry.timestamp),
                    className: 'date'
                });
                header.appendChild(timeDiv);

                const historyItem = Utils.createElement('div', {
                    className: 'history-item'
                });
                historyItem.appendChild(header);
                if (entry.username.toUpperCase() === 'XNITE') {
                    historyItem.style.filter = 'contrast(1.06)';
                }

                if (entry.diff === '(No changes)') {
                    const noChangesDiv = Utils.createElement('div', {
                        textContent: '(No changes)',
                        style: {
                            color: '#796a5a61',
                            fontWeight: 'bolder',
                            transform: 'rotate(2deg)',
                            padding: '10px',
                            textAlign: 'center'
                        }
                    });
                    historyItem.appendChild(noChangesDiv);
                    container.appendChild(historyItem);
                    return;
                }

                const diffLines = entry.diff?.split('\n') || [];
                const changes = this.processChanges(diffLines);

                let anySectionAdded = false;

                const formatters = {
                    added: this.formatAddedItem,
                    removed: this.formatRemovedItem,
                    weeklystar: this.formatBooleanItem,
                    weekly: this.formatBooleanItem,
                    new: this.formatBooleanItem,
                    retired: this.formatBooleanItem,
                    removed: this.formatBooleanItem,
                    premium: this.formatBooleanItem,
                    tradable: this.formatBooleanItem,
                    demand: this.formatDemandItem,
                    img: this.formatImageItem,  // Changed from 'icon' to 'img'
                    svg: this.formatImageItem,  // Added svg formatter
                    price: this.formatPriceItem,
                    from: this.formatDescriptionItem,
                    'price/code/rarity': this.formatDescriptionItem
                };

                for (const [title, changeKey] of this.SECTION_CONFIG) {
                    const section = this.createSection(title, changes[changeKey], formatters[changeKey]);
                    if (section) {
                        historyItem.appendChild(section);
                        anySectionAdded = true;
                    }
                }

                // Only show raw diff as fallback if nothing was processed
                if (!anySectionAdded) {
                    // Check if this might be unprocessed added/removed items
                    if (entry.diff && (entry.diff.includes('ðŸ†• Added:') || entry.diff.includes('âŒ Removed:'))) {
                        console.warn('Unprocessed added/removed items format:', entry.diff);
                    }
                    historyItem.textContent = entry.diff || '(no diff available)';
                }

                container.appendChild(historyItem);
            }
        };


        // Add this JSON Import Manager to your code (can be added after ErrorHandler or anywhere in your managers section)
        const JSONImportManager = {
            // Configuration
            config: {
                MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB max
                REQUIRED_CATEGORIES: ['gears', 'titles', 'effects', 'pets', 'deaths'], // Add your required categories
            },

            // Import JSON from file
            async importJSON(file) {
                try {
                    // Validate file
                    if (!this.validateFile(file)) {
                        console.log(this.validateFile(file))
                        return false;
                    }

                    // Show loading
                    ErrorHandler.showToast('Reading file...', 'info');

                    // Read file content
                    const content = await this.readFile(file);

                    // Parse JSON
                    let importedData;
                    try {
                        importedData = JSON.parse(content);
                    } catch (parseError) {
                        ErrorHandler.showToast('Invalid JSON format', 'error');
                        return false;
                    }

                    // Validate structure
                    if (!this.validateStructure(importedData)) {
                        return false;
                    }

                    // Show confirmation modal
                    const confirmed = await this.showConfirmationModal(importedData);

                    if (!confirmed) {
                        return false;
                    }

                    // Apply the imported data
                    this.applyImportedData(importedData);



                    return true;

                } catch (error) {
                    console.error('Import error:', error);
                    ErrorHandler.showToast('Failed to import JSON: ' + error.message, 'error');
                    return false;
                }
            },

            // Read file as text
            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();

                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(new Error('Failed to read file'));

                    reader.readAsText(file);
                });
            },

            // Validate file before processing
            validateFile(file) {
                // Check file type
                if (!file.type.includes('json') && !file.name.endsWith('.json')) {
                    ErrorHandler.showToast('Please select a JSON file', 'error');
                    return false;
                }

                // Check file size
                if (file.size > this.config.MAX_FILE_SIZE) {
                    ErrorHandler.showToast(`File too large (max ${this.config.MAX_FILE_SIZE / 1024 / 1024}MB)`, 'error');
                    return false;
                }

                //if required categorys not found then return false
                for (const category of this.config.REQUIRED_CATEGORIES) {
                    console.log(state.jsData.hasOwnProperty(category));
                    if (!state.jsData.hasOwnProperty(category)) {
                        ErrorHandler.showToast(`Current data missing required category: ${category}`, 'error');

                        return false;
                    }
                }

                return true;
            },

            // Validate JSON structure
            validateStructure(data) {
                // Check if it's an object
                if (typeof data !== 'object' || data === null) {
                    ErrorHandler.showToast('Invalid JSON structure: expected object', 'error');
                    return false;
                }

                // Check for required categories (optional - adjust based on your needs)
                const categories = Object.keys(data);
                if (categories.length === 0) {
                    ErrorHandler.showToast('JSON file is empty', 'error');
                    return false;
                }

                // Validate each category contains an array
                for (const [category, items] of Object.entries(data)) {
                    if (!Array.isArray(items)) {
                        ErrorHandler.showToast(`Invalid structure: "${category}" must be an array`, 'error');
                        return false;
                    }

                    // Validate items in category have required fields
                    for (const item of items) {
                        if (!item.name) {
                            ErrorHandler.showToast(`Invalid item in "${category}": missing name field`, 'error');
                            return false;
                        }
                    }
                }

                return true;
            },

            // Show confirmation modal before import
            showConfirmationModal(importedData) {
                return new Promise((resolve) => {
                    // Calculate statistics and get diff
                    const stats = this.calculateStats(importedData);
                    const diff = this.calculateDiff(importedData);

                    // Create modal
                    const modal = document.createElement('div');
                    modal.className = 'publish-modal-overlay';
                    modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.7);
                backdrop-filter: blur(4px);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;

                    const content = document.createElement('div');
                    content.className = 'delete-modal';
                    content.style.cssText = `
                max-width: 90%;
                width: 600px;
                padding: 0;
                overflow: hidden;
                max-height: 80vh;
                display: flex;
                flex-direction: column;
            `;

                    // Generate diff HTML
                    const diffHTML = this.generateDiffHTML(diff);

                    content.innerHTML = `
                <div style="padding: 20px; border-bottom: 1px solid var(--shade, #374151); 
                            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.1));">
                    <h2 style="margin: 0; font-size: 24px; color: white; display: flex; align-items: center; gap: 10px;">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="12" y1="18" x2="12" y2="12"></line>
                            <line x1="9" y1="15" x2="15" y2="15"></line>
                        </svg>
                        Import JSON Data
                    </h2>
                    <p style="margin: 8px 0 0 0; color: #fbbf24; font-weight: 500;">
                        âš ï¸ This will replace all current data
                    </p>
                    <p style="margin: 4px 0 0 0; color: #3b82f6; font-size: 13px;">
                        â„¹ï¸ You'll need to publish after importing to save changes to the server
                    </p>
                </div>
                
                <div style="padding: 20px; overflow-y: auto; flex: 1;">
                    <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); 
                                border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                        <h3 style="margin: 0 0 8px 0; color: #3b82f6; font-size: 14px;">Import Statistics:</h3>
                        <div style="color: #d1d5db; font-size: 14px;">
                            <div>â€¢ Total Items: ${stats.totalItems}</div>
                            <div>â€¢ New Items: ${stats.newItems}</div>
                            <div>â€¢ Removed Items: ${stats.removedItems}</div>
                            <div>â€¢ Unchanged Items: ${stats.unchangedItems}</div>
                        </div>
                    </div>
                    
                    ${diffHTML}
                    
                    <div style="background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); 
                                border-radius: 8px; padding: 12px; margin-top: 16px;">
                        <strong style="color: #fbbf24;">Current Data:</strong>
                        <div style="color: #9ca3af; margin-top: 4px; font-size: 14px;">
                            â€¢ ${state.allItems.length} total items
                            â€¢ All unsaved changes will be lost
                        </div>
                    </div>
                </div>
                
                <div style="border-top: 1px solid var(--shade, #374151); padding: 16px; 
                            display: flex; gap: 12px; justify-content: flex-end;">
                    <button class="small-btn ghost" id="cancel-import">Cancel</button>
                    <button class="small-btn" id="confirm-import" style="background: linear-gradient(135deg, #3b82f6, #9333ea);">
                        Import & Replace
                    </button>
                </div>
            `;

                    modal.appendChild(content);
                    document.body.appendChild(modal);

                    // Animate in
                    requestAnimationFrame(() => {
                        modal.style.opacity = '1';
                    });

                    // Event handlers
                    document.getElementById('cancel-import').onclick = () => {
                        modal.style.opacity = '0';
                        setTimeout(() => modal.remove(), 300);
                        resolve(false);
                    };

                    document.getElementById('confirm-import').onclick = () => {
                        modal.style.opacity = '0';
                        setTimeout(() => modal.remove(), 300);
                        resolve(true);
                    };

                    // Close on escape
                    const escHandler = (e) => {
                        if (e.key === 'Escape') {
                            modal.style.opacity = '0';
                            setTimeout(() => modal.remove(), 300);
                            document.removeEventListener('keydown', escHandler);
                            resolve(false);
                        }
                    };
                    document.addEventListener('keydown', escHandler);
                });
            },

            // Calculate statistics about imported data
            calculateStats(data) {
                const currentItems = Object.values(state.jsData).flat();
                const importedItems = Object.values(data).flat();

                const currentItemNames = new Set(currentItems.map(item => item.name));
                const importedItemNames = new Set(importedItems.map(item => item.name));

                const newItems = [...importedItemNames].filter(name => !currentItemNames.has(name));
                const removedItems = [...currentItemNames].filter(name => !importedItemNames.has(name));
                const unchangedItems = [...currentItemNames].filter(name => importedItemNames.has(name));

                return {
                    totalItems: importedItems.length,
                    newItems: newItems.length,
                    removedItems: removedItems.length,
                    unchangedItems: unchangedItems.length
                };
            },

            // Calculate detailed diff between current and imported data
            calculateDiff(importedData) {
                const diff = {
                    added: {},
                    removed: {},
                    unchanged: {}
                };

                // Get all categories from both datasets
                const allCategories = new Set([
                    ...Object.keys(state.jsData),
                    ...Object.keys(importedData)
                ]);

                for (const category of allCategories) {
                    const currentItems = state.jsData[category] || [];
                    const importedItems = importedData[category] || [];

                    const currentNames = new Set(currentItems.map(item => item.name));
                    const importedNames = new Set(importedItems.map(item => item.name));

                    // Find added items in this category
                    const addedInCategory = importedItems
                        .filter(item => !currentNames.has(item.name))
                        .map(item => item.name);

                    if (addedInCategory.length > 0) {
                        diff.added[category] = addedInCategory;
                    }

                    // Find removed items in this category
                    const removedInCategory = currentItems
                        .filter(item => !importedNames.has(item.name))
                        .map(item => item.name);

                    if (removedInCategory.length > 0) {
                        diff.removed[category] = removedInCategory;
                    }

                    // Find unchanged items in this category
                    const unchangedInCategory = currentItems
                        .filter(item => importedNames.has(item.name))
                        .map(item => item.name);

                    if (unchangedInCategory.length > 0) {
                        diff.unchanged[category] = unchangedInCategory;
                    }
                }

                return diff;
            },

            // Generate HTML for diff display
            generateDiffHTML(diff) {
                let html = '';

                // Show removed items
                if (Object.keys(diff.removed).length > 0) {
                    html += `
                <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); 
                            border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                    <h3 style="margin: 0 0 8px 0; color: #ef4444; font-size: 14px; display: flex; align-items: center; gap: 6px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="8" y1="12" x2="16" y2="12"></line>
                        </svg>
                        Removed Items (${Object.values(diff.removed).flat().length})
                    </h3>
                    <div style="color: #fca5a5; font-size: 13px; max-height: 150px; overflow-y: auto;">
                        ${this.formatDiffList(diff.removed)}
                    </div>
                </div>
            `;
                }

                // Show added items
                if (Object.keys(diff.added).length > 0) {
                    html += `
                <div style="background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); 
                            border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                    <h3 style="margin: 0 0 8px 0; color: #22c55e; font-size: 14px; display: flex; align-items: center; gap: 6px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="16"></line>
                            <line x1="8" y1="12" x2="16" y2="12"></line>
                        </svg>
                        New Items (${Object.values(diff.added).flat().length})
                    </h3>
                    <div style="color: #86efac; font-size: 13px; max-height: 150px; overflow-y: auto;">
                        ${this.formatDiffList(diff.added)}
                    </div>
                </div>
            `;
                }

                if (!html) {
                    html = `
                <div style="background: rgba(156, 163, 175, 0.1); border: 1px solid rgba(156, 163, 175, 0.3); 
                            border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                    <p style="margin: 0; color: #9ca3af; text-align: center;">No changes detected</p>
                </div>
            `;
                }

                return html;
            },

            // Format diff list as nested bullets
            formatDiffList(items) {
                let html = '<ul style="margin: 0; padding-left: 20px; list-style: disc;">';

                for (const [category, categoryItems] of Object.entries(items)) {
                    html += `
                <li style="margin-bottom: 6px;">
                    <strong>${category}</strong>
                    <ul style="margin: 4px 0 0 0; padding-left: 20px; list-style: circle;">
                        ${categoryItems.map(item =>
                        `<li style="margin: 2px 0;">${this.escapeHtml(item)}</li>`
                    ).join('')}
                    </ul>
                </li>
            `;
                }

                html += '</ul>';
                return html;
            },

            // Escape HTML to prevent XSS
            escapeHtml(text) {
                const map = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#039;'
                };
                return text.replace(/[&<>"']/g, m => map[m]);
            },

            // Apply imported data to state
            applyImportedData(data) {
                // Clear change tracking


                // Get current server state to compare against
                const serverItems = new Set();
                ChangeTracker.originalItems.forEach((_, itemName) => {
                    serverItems.add(itemName);
                });

                // Update state with imported data
                state.jsData = JSON.parse(JSON.stringify(data)); // Deep clone to avoid reference issues
                state.allItems = Object.values(state.jsData).flat();

                // Mark all imported items as changes
                const importedItems = new Set();
                state.allItems.forEach(item => {
                    importedItems.add(item.name);

                    // If this item wasn't in the original server data, mark as new
                    if (!serverItems.has(item.name)) {
                        ChangeTracker.markAsNew(item.name);
                    } else {
                        // If it exists, check if it's different and mark as modified
                        const originalJson = ChangeTracker.originalItems.get(item.name);
                        if (originalJson) {
                            const original = JSON.parse(originalJson);
                            if (ChangeTracker.compareItems(original, item)) {
                                ChangeTracker.modifiedItems.add(item.name);
                            }
                        }
                    }
                });

                // Mark items that were on server but not in import as deleted
                serverItems.forEach(itemName => {
                    if (!importedItems.has(itemName)) {
                        const originalJson = ChangeTracker.originalItems.get(itemName);
                        if (originalJson) {
                            ChangeTracker.markAsDeleted(itemName, JSON.parse(originalJson));
                        }
                    }
                });

                // Reset filters and pagination
                state.currentPage = 1;
                state.filters = {
                    search: '',
                    category: 'all',
                    gamenightOnly: false,
                    sort: 'default',
                    showPrices: false,
                    newestOnly: false
                };

                // Update UI
                UI.renderFilterControls();
                UI.renderShops();
                UI.renderItems();

                // Clear undo/redo history since we have new data
                UndoRedoManager.clear();

                // Update visual highlights to show all the changes
                ChangeTracker.updateHighlights();

                // Show a toast with change count
                const changes = ChangeTracker.getAllChanges();
                const totalChanges = changes.newItems.length + changes.modifiedItems.length + changes.deletedItems.length;
                if (totalChanges > 0) {
                    ErrorHandler.showToast(`âœ“ Imported with ${totalChanges} change${totalChanges !== 1 ? 's' : ''} ready to publish`, 'success');
                };
            }
        };
        // ============================
        // Notes Manager
        // ============================

        const NotesManager = {
            contextMenu: null,
            currentNoteIndex: null,

            init() {
                const addBtn = DOM.get('addButton');
                const inputForm = DOM.get('inputForm');
                const noteInput = DOM.get('noteInput');
                const sendBtn = DOM.get('sendNoteBtn');

                addBtn.addEventListener('click', () => this.toggleForm());
                sendBtn.addEventListener('click', () => this.sendNote());

                noteInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.sendNote();
                    } else if (e.key === 'Escape') {
                        this.cancelNote();
                    }
                });

                // Click outside to close
                document.addEventListener('click', (e) => {
                    if (inputForm.classList.contains('active') &&
                        !addBtn.contains(e.target) &&
                        !inputForm.contains(e.target)) {
                        this.cancelNote();
                    }

                    // Also close context menu
                    if (this.contextMenu && !this.contextMenu.contains(e.target)) {
                        this.hideContextMenu();
                    }
                });

                // Prevent default context menu
                document.addEventListener('contextmenu', (e) => {
                    if (e.target.closest('.stickynote')) {
                        e.preventDefault();
                    }
                });

                // Create delete modal on init
                this.createDeleteModal();
                this.createContextMenu();
            },

            createContextMenu() {
                // Remove existing if any
                if (this.contextMenu) {
                    this.contextMenu.remove();
                }

                this.contextMenu = document.createElement('div');
                this.contextMenu.className = 'notes-context-menu';
                this.contextMenu.style.cssText = `
            position: fixed;
            background: linear-gradient(137deg, rgba(74, 87, 97, 0.24), rgba(74, 81, 94, 0.37), rgba(66, 84, 98, 0.13));
            border: 1px solid var(--shade, #374151);
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10001;
            display: none;
            backdrop-filter: blur(23px);
        `;

                // Create menu structure
                this.contextMenu.innerHTML = `
            <div class="context-menu-section">
                <div class="context-menu-label">React</div>
                <div class="context-menu-reactions">
                    <span class="reaction-option" data-emoji="ðŸ‘">ðŸ‘</span>
                    <span class="reaction-option" data-emoji="â¤ï¸">â¤ï¸</span>
                    <span class="reaction-option" data-emoji="ðŸ˜‚">ðŸ˜‚</span>
                    <span class="reaction-option" data-emoji="ðŸ”¥">ðŸ”¥</span>
                    <span class="reaction-option" data-emoji="ðŸ‘€">ðŸ‘€</span>
                    <span class="reaction-option" data-emoji="âœ…">âœ…</span>
                </div>
            </div>
            <div class="context-menu-divider"></div>
            <div class="context-menu-item delete-option">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="74.2895 78.773 20.0031 20" style="margin-bottom: -5px;" width="16px" height="16px">
  <path d="M 79.291 80.773 C 79.291 79.668 80.186 78.773 81.291 78.773 L 87.291 78.773 C 88.396 78.773 89.291 79.668 89.291 80.773 L 89.291 82.773 L 93.291 82.773 C 94.061 82.773 94.542 83.606 94.157 84.273 C 93.978 84.582 93.648 84.773 93.291 84.773 L 92.222 84.773 L 91.355 96.915 C 91.281 97.961 90.409 98.773 89.36 98.773 L 79.221 98.773 C 78.172 98.773 77.301 97.961 77.226 96.915 L 76.361 84.773 L 75.291 84.773 C 74.521 84.773 74.04 83.939 74.425 83.273 C 74.604 82.963 74.934 82.773 75.291 82.773 L 79.291 82.773 L 79.291 80.773 Z M 81.291 82.773 L 87.291 82.773 L 87.291 80.773 L 81.291 80.773 L 81.291 82.773 Z" style="stroke-width: 1; fill: #cf2026" transform="matrix(1, 0, 0, 1, 7.105427357601002e-15, 1.4210854715202004e-14)"/>
  <path d="M 79.291 80.773 C 79.291 79.668 80.186 78.773 81.291 78.773 L 87.291 78.773 C 88.396 78.773 89.291 79.668 89.291 80.773 L 89.291 82.773 L 93.291 82.773 C 94.061 82.773 94.542 83.606 94.157 84.273 C 93.978 84.582 93.648 84.773 93.291 84.773 L 92.222 84.773 L 91.355 96.915 C 91.281 97.961 90.409 98.773 89.36 98.773 L 79.221 98.773 C 78.172 98.773 77.301 97.961 77.226 96.915 L 76.361 84.773 L 75.291 84.773 C 74.521 84.773 74.04 83.939 74.425 83.273 C 74.604 82.963 74.934 82.773 75.291 82.773 L 79.291 82.773 L 79.291 80.773 Z M 81.291 82.773 L 87.291 82.773 L 87.291 80.773 L 81.291 80.773 L 81.291 82.773 Z M 78.365 84.773 L 79.222 96.773 L 89.361 96.773 L 90.218 84.773 L 78.365 84.773 Z M 82.291 86.773 C 82.843 86.773 83.291 87.22 83.291 87.773 L 83.291 93.773 C 83.291 94.542 82.458 95.024 81.791 94.639 C 81.482 94.46 81.291 94.13 81.291 93.773 L 81.291 87.773 C 81.291 87.22 81.739 86.773 82.291 86.773 Z M 86.291 86.773 C 86.843 86.773 87.291 87.22 87.291 87.773 L 87.291 93.773 C 87.291 94.542 86.458 95.024 85.791 94.639 C 85.482 94.46 85.291 94.13 85.291 93.773 L 85.291 87.773 C 85.291 87.22 85.739 86.773 86.291 86.773 Z" style="stroke-width: 1;" transform="matrix(1, 0, 0, 1, 7.105427357601002e-15, 1.4210854715202004e-14)"/>
</svg>
                <span style="line-height: 15px;border: 0;font-size: 17px;color: #ff1f27;padding:0px 6px 0px 0px;background:transparent;margin-right:8px;vertical-align:middle;font-variant: all-petite-caps;font-size:17px;pointer-events:none;text-shadow: -1.3px -1.3px 0 #000, 0 -1.3px 0 #000, 1.3px -1.3px 0 #000, 1.3px 0 0 #000, 1.3px 1.3px 0 #000, 0 1.3px 0 #000, -1.3px 1.3px 0 #000, -1.3px 0 0 #000;"> DELETE NOTE</span>

                </div>
        `;

                document.body.appendChild(this.contextMenu);
                // Event handlers
                this.contextMenu.querySelectorAll('.reaction-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const emoji = option.dataset.emoji;
                        this.addReaction(this.currentNoteIndex, emoji);
                        this.hideContextMenu();
                    });
                });

                this.contextMenu.querySelector('.delete-option').addEventListener('click', () => {
                    this.hideContextMenu();
                    this.showDeleteModal(this.currentNoteIndex);
                });
            },

            showContextMenu(e, noteIndex) {
                this.currentNoteIndex = noteIndex;
                const note = state.notes[noteIndex];

                // Update reaction options to show which ones are selected
                this.contextMenu.querySelectorAll('.reaction-option').forEach(option => {
                    const emoji = option.dataset.emoji;
                    option.classList.remove('selected');

                    // Check if current user has reacted with this emoji
                    if (note?.reactions?.[emoji]?.users?.includes(state.adminName)) {
                        option.classList.add('selected');
                    }
                });

                // Position the menu
                const x = e.clientX;
                const y = e.clientY;

                // Show menu first to get dimensions
                this.contextMenu.style.display = 'block';

                // Adjust position if it would go off-screen
                const menuRect = this.contextMenu.getBoundingClientRect();
                const finalX = Math.min(x, window.innerWidth - menuRect.width - 10);
                const finalY = Math.min(y, window.innerHeight - menuRect.height - 10);

                this.contextMenu.style.left = `${finalX}px`;
                this.contextMenu.style.top = `${finalY}px`;

                // Add show animation
                this.contextMenu.style.opacity = '0';
                this.contextMenu.style.transform = 'scale(0.95)';

                requestAnimationFrame(() => {
                    this.contextMenu.style.transition = 'opacity 0.2s, transform 0.2s';
                    this.contextMenu.style.opacity = '1';
                    this.contextMenu.style.transform = 'scale(1)';
                });
            },

            hideContextMenu() {
                if (this.contextMenu) {
                    this.contextMenu.style.opacity = '0';
                    this.contextMenu.style.transform = 'scale(0.95)';

                    setTimeout(() => {
                        this.contextMenu.style.display = 'none';
                        this.currentNoteIndex = null;
                    }, 200);
                }
            },

            addReaction(noteIndex, emoji) {
                const note = state.notes[noteIndex];
                if (!note) return;

                // Initialize reactions if not exists
                if (!note.reactions) {
                    note.reactions = {};
                }

                // Toggle reaction for current user
                if (!note.reactions[emoji]) {
                    note.reactions[emoji] = { users: [], count: 0 };
                }

                const userIndex = note.reactions[emoji].users.indexOf(state.adminName);
                if (userIndex === -1) {
                    // Add reaction
                    note.reactions[emoji].users.push(state.adminName);
                    note.reactions[emoji].count++;
                } else {
                    // Remove reaction
                    note.reactions[emoji].users.splice(userIndex, 1);
                    note.reactions[emoji].count--;

                    // Remove emoji if no reactions
                    if (note.reactions[emoji].count === 0) {
                        delete note.reactions[emoji];
                    }
                }

                // Send update to server with the actual note ID
                if (state.ws.notes && state.ws.notes.send) {
                    state.ws.notes.send({
                        type: 'react',
                        noteId: note.id,  // Make sure we're using the note's actual ID
                        reactions: note.reactions,
                        author: state.adminName
                    });
                }

                // Update local render immediately for responsive feel
                this.render();
            },
            createDeleteModal() {
                // Remove existing modal if any
                const existingModal = document.getElementById('deleteModal');
                if (existingModal) {
                    existingModal.remove();
                }

                const modalHTML = `
            <div id="deleteModal" class="delete-modal-overlay">
                <div class="delete-modal">
                    <div class="delete-modal-header">Delete Note</div>
                    <div class="delete-modal-content">
                        Are you sure you want to delete this note? This action cannot be undone.
                        <div id="deleteNotePreview" class="delete-modal-note-preview"></div>
                    </div>
                    <div class="delete-modal-buttons">
                        <button id="cancelDeleteBtn" class="small-btn ghost">Cancel</button>
                        <button id="confirmDeleteBtn" class="small-btn danger">Delete</button>
                    </div>
                </div>
            </div>
        `;

                document.body.insertAdjacentHTML('beforeend', modalHTML);

                // Add event listeners
                const modal = document.getElementById('deleteModal');
                const cancelBtn = document.getElementById('cancelDeleteBtn');
                const confirmBtn = document.getElementById('confirmDeleteBtn');

                // Close modal events
                cancelBtn.addEventListener('click', () => this.hideDeleteModal());

                // Click outside to close
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.hideDeleteModal();
                    }
                });

                // Escape key to close
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.classList.contains('active')) {
                        this.hideDeleteModal();
                    }
                });
            },

            showDeleteModal(index) {
                const modal = document.getElementById('deleteModal');
                const preview = document.getElementById('deleteNotePreview');
                const confirmBtn = document.getElementById('confirmDeleteBtn');
                const note = state.notes[index];

                if (!note) return;

                // Update preview content
                const truncatedContent = note.content.length > 50
                    ? note.content.substring(0, 50) + '...'
                    : note.content;
                preview.textContent = `"${truncatedContent}"`;

                // Update confirm button click handler
                confirmBtn.onclick = () => {
                    this.deleteNote(index);
                    this.hideDeleteModal();
                };

                // Show modal
                modal.classList.add('active');

                // Focus the cancel button for better UX
                setTimeout(() => {
                    document.getElementById('cancelDeleteBtn').focus();
                }, 100);
            },

            hideDeleteModal() {
                const modal = document.getElementById('deleteModal');
                modal.classList.remove('active');
            },

            deleteNote(index) {
                const note = state.notes[index];
                if (!note) return;

                state.ws.notes.send({
                    type: 'delete',
                    id: note.id,
                    author: state.adminName
                });
                state.notes.splice(index, 1);
                this.render();
            },

            toggleForm() {
                const addBtn = DOM.get('addButton');
                const inputForm = DOM.get('inputForm');

                if (!addBtn.classList.contains('expanded')) {
                    addBtn.classList.add('expanded');
                    addBtn.classList.remove('add-button');
                    addBtn.innerHTML = '';
                    addBtn.appendChild(inputForm);
                    inputForm.classList.add('active');

                    setTimeout(() => {
                        DOM.get('noteInput').focus();
                    }, 300);
                }
            },

            cancelNote() {
                const addBtn = DOM.get('addButton');
                const inputForm = DOM.get('inputForm');
                const noteInput = DOM.get('noteInput');

                addBtn.classList.add('add-button');
                addBtn.classList.remove('expanded');
                inputForm.classList.remove('active');
                addBtn.innerHTML = 'âž•';
                addBtn.style.fontFamily = "\'Segoe UI Symbol\', sans-serif"
                noteInput.value = '';
                document.body.appendChild(inputForm);
            },

            adjustBulletinHeight() {
                const container = DOM.get('notesArea');
                container.style.height = 'fit-content';

                const height = isTouch ? 284 : 265; // Max height before scrolling

                if (container.offsetHeight > height) {
                    container.classList.add('scroll');
                    container.style.height = '';
                } else {
                    container.classList.remove('scroll');
                }
            },

            sendNote() {
                const noteInput = DOM.get('noteInput');
                const content = noteInput.value.trim();

                if (!content) {
                    noteInput.focus();
                    return;
                }

                state.ws.notes.send({
                    type: 'create',
                    content,
                    author: state.adminName
                });

                this.cancelNote();
                this.adjustBulletinHeight();
            },

            render() {
                const container = DOM.get('notesArea');
                container.innerHTML = '';

                state.notes.forEach((note, index) => {
                    const noteEl = Utils.createElement('div', {
                        class: 'stickynote',
                        dataset: { index }
                    });

                    const pin = Utils.createElement('div', { class: 'pin' });
                    const content = Utils.createElement('div', {
                        class: 'note-content',
                        innerHTML: note.content
                    });
                    const author = Utils.createElement('div', {
                        class: 'note-author',
                        textContent: '@' + note.author
                    });
                    const time = Utils.createElement('div', {
                        class: 'note-time',
                        textContent: this.formatTime(note.timestamp)
                    });

                    // Add reactions display
                    if (note.reactions && Object.keys(note.reactions).length > 0) {
                        const reactionsEl = Utils.createElement('div', {
                            class: 'note-reactions'
                        });

                        Object.entries(note.reactions).forEach(([emoji, data]) => {
                            if (data.count > 0) {
                                const reactionEl = Utils.createElement('div', {
                                    class: 'note-reaction',
                                    title: data.users.join(', ')
                                });

                                reactionEl.innerHTML = `
                            <span>${emoji}</span>
                            ${data.count > 1 ? `<span class="note-reaction-count">${data.count}</span>` : ''}
                        `;

                                reactionsEl.appendChild(reactionEl);
                            }
                        });

                        noteEl.appendChild(reactionsEl);
                    }

                    noteEl.appendChild(pin);
                    noteEl.appendChild(content);
                    noteEl.appendChild(author);
                    noteEl.appendChild(time);

                    // Context menu on right-click
                    noteEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        this.showContextMenu(e, index);
                    });

                    // Long press for mobile (keep existing)
                    let isMoved = false;
                    noteEl.addEventListener('touchmove', () => {
                        isMoved = true;
                    });
                    let pressTimer;
                    noteEl.addEventListener('touchstart', (e) => {
                        pressTimer = setTimeout(() => {
                            if (!isMoved) {
                                const touch = e.touches[0];
                                const fakeEvent = {
                                    clientX: touch.clientX,
                                    clientY: touch.clientY
                                };
                                this.showContextMenu(fakeEvent, index);
                            }
                        }, 600);
                    });
                    noteEl.addEventListener('touchend', () => clearTimeout(pressTimer));

                    container.appendChild(noteEl);
                });

                this.adjustBulletinHeight();
                container.scrollTop = container.scrollHeight;
            },

            // Updated method - now calls showDeleteModal instead of using confirm()
            promptDelete(index) {
                this.showDeleteModal(index);
                this.adjustBulletinHeight();
            },

            formatTime(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);

                if (diffMins < 1) return 'now';
                if (diffMins < 60) return `${diffMins}m`;
                if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h`;
                return `${Math.floor(diffMins / 1440)}d`;
            }
        };

        // ============================
        // Panels Manager (FIXED)
        // ============================
        const PanelsManager = {
            panels: [
                { id: 'history-section', name: 'History', sectionId: 'history-section' },
                { id: 'gallery-moderation-section', name: 'Gallery Moderation', sectionId: 'gallery-moderation-section' },
                { id: 'demand-review-section', name: 'Demand Review', sectionId: 'demand-review-section' },
                { id: 'user-management-section', name: 'User Management', sectionId: 'user-management-section' },
                { id: 'notes-section', name: 'Notes', sectionId: 'notes-section' }
            ],

            hiddenPanels: new Set(),

            init() {
                // Load saved state
                const saved = []
                this.hiddenPanels = new Set(saved);

                // Setup close button handlers for existing buttons
                this.setupCloseButtons();

                // Setup panels menu
                this.setupPanelsMenu();

            },

            setupCloseButtons() {
                // Just attach handlers to existing close buttons
                DOM.queryAll('.section-close-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();

                        // Find the parent section
                        const section = btn.closest('.section');
                        if (section) {
                            const panelId = section.id || 'shops-container';
                            this.togglePanel(panelId, false);
                        }
                    });
                });
            },

            setupPanelsMenu() {
                const panelsBtn = DOM.get('panels-btn');
                const panelsMenu = DOM.get('panels-menu');

                if (!panelsBtn || !panelsMenu) return;

                // Toggle menu on button click
                panelsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    DOM.queryAll('.menu').forEach(menu => {
                        menu.id === panelsMenu.id ? menu.classList.toggle('show') : menu.classList.remove('show');
                    });
                    this.renderPanelsList();
                });

                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!panelsMenu.contains(e.target) && e.target !== panelsBtn) {
                        panelsMenu.classList.remove('show');
                    }
                });
            },

            renderPanelsList() {
                const container = DOM.get('panels-list');
                if (!container) return;

                container.innerHTML = '';

                this.panels.forEach(panel => {
                    const isHidden = this.hiddenPanels.has(panel.id);

                    const toggle = Utils.createElement('div', {
                        className: `panel-toggle ${isHidden ? 'hidden2' : ''}`,
                        onclick: () => this.togglePanel(panel.id)
                    });

                    const name = Utils.createElement('span', {
                        textContent: panel.name
                    });

                    const status = Utils.createElement('span', {
                        className: 'status'
                    });

                    toggle.appendChild(name);
                    toggle.appendChild(status);
                    container.appendChild(toggle);
                });
            },

            togglePanel(panelId, show = null) {
                const panel = this.panels.find(p => p.id === panelId || p.sectionId === panelId);
                if (!panel) return;

                // Get the actual section element
                let sectionElement;
                if (panel.id === 'shops-container') {
                    // Special case for shops - hide the entire lists-section
                    sectionElement = DOM.get('lists-section');
                } else {
                    sectionElement = DOM.get(panel.sectionId);
                }

                if (!sectionElement) return;

                // Determine new state
                const shouldShow = show !== null ? show : this.hiddenPanels.has(panel.id);

                if (shouldShow) {
                    // Show panel
                    sectionElement.style.display = '';
                    this.hiddenPanels.delete(panel.id);
                } else {
                    // Hide panel
                    sectionElement.style.display = 'none';
                    this.hiddenPanels.add(panel.id);
                }

                const publishSection = DOM.get('publish-section');
                if (publishSection) {
                    publishSection.style.position = this.hiddenPanels.size >= 2 ? 'unset' : '';
                }

                // Save state
                Utils.storage.set('hiddenPanels', Array.from(this.hiddenPanels));

                // Update menu if open
                if (DOM.get('panels-menu').classList.contains('show')) {
                    this.renderPanelsList();
                }

                // Update badge
                this.updateBadge();
            },

            updateBadge() {
                const btn = DOM.get('panels-btn');
                if (!btn) return;

                const count = this.hiddenPanels.size;
                if (count > 0) {
                    btn.setAttribute('data-badge', count);
                    btn.style.position = 'relative';

                    // Add badge styles if not exists
                    if (!document.querySelector('#panels-badge-style')) {
                        const style = Utils.createElement('style', {
                            id: 'panels-badge-style',
                            textContent: `
                        #panels-btn[data-badge]:after {
                            content: attr(data-badge);
                            font-family: 'BuilderSans';
                            position: absolute;
                            top: -4px;
                            right: -4px;
                            background: #ef4444;
                            color: white;
                            border-radius: 10px;
                            padding: 2px 6px;
                            font-size: 11px;
                            font-weight: bold;
                        }
                    `
                        });
                        document.head.appendChild(style);
                    }
                } else {
                    btn.removeAttribute('data-badge');
                }
            }
        };

        // ============================
        // Enhanced Publish Manager
        // ============================
        const PublishManager = {
            // Generate a diff summary of all changes
            generateChangeSummary() {
                const changes = {
                    modified: [],
                    added: [],
                    removed: []
                };

                // Process new items
                ChangeTracker.newItems.forEach(itemName => {
                    const currentItem = state.allItems.find(i => i.name === itemName);
                    if (currentItem) {
                        changes.added.push({
                            name: itemName,
                            item: currentItem
                        });
                    }
                });

                // Process modified items
                ChangeTracker.modifiedItems.forEach(itemName => {
                    const currentItem = state.allItems.find(i => i.name === itemName);
                    const originalJson = ChangeTracker.originalItems.get(itemName);

                    if (currentItem && originalJson) {
                        const originalItem = JSON.parse(originalJson);
                        const itemChanges = this.compareItems(originalItem, currentItem);

                        if (itemChanges.length > 0) {
                            changes.modified.push({
                                name: itemName,
                                changes: itemChanges,
                                original: originalItem,
                                current: currentItem
                            });
                        }
                    }
                });

                // Process deleted items
                ChangeTracker.deletedItems.forEach((originalStateJson, itemName) => {
                    const originalItem = typeof originalStateJson === 'string'
                        ? JSON.parse(originalStateJson)
                        : originalStateJson;

                    changes.removed.push({
                        name: itemName,
                        item: originalItem
                    });
                });

                return changes;
            },

            // Compare two items and return list of changes
            compareItems(original, current) {
                const changes = [];
                const fields = ['name', 'img', 'svg', 'price', 'from', 'price/code/rarity',
                    'weekly', 'weeklystar', 'new', 'retired', 'premium', 'tradable', 'removed', 'demand'];

                fields.forEach(field => {
                    const oldVal = this.normalizeValue(field, original[field]);
                    const newVal = this.normalizeValue(field, current[field]);

                    if (oldVal !== newVal) {
                        changes.push({
                            field,
                            oldValue: original[field],
                            newValue: current[field],
                            display: this.formatFieldChange(field, original[field], current[field])
                        });
                    }
                });

                return changes;
            },

            normalizeValue(field, value) {
                if (field === 'price') {
                    if (!value || value === '' || value === 'N/A' || value === 'undefined') {
                        return '0';
                    }
                    return String(value);
                }
                return value;
            },

            formatFieldChange(field, oldValue, newValue) {
                const formatters = {
                    'img': (old, val) => {
                        const getFilename = (url) => {
                            if (!url) return 'none';
                            const parts = url.split('/');
                            return parts[parts.length - 1] || url;
                        };
                        return `Image: ${getFilename(old)} â†’ ${getFilename(val)}`;
                    },
                    'svg': (old, val) => `SVG code updated`,
                    'price': (old, val) => `RAP: ${old || '0'} â†’ ${val || '0'}`,
                    'from': (old, val) => `Description changed`,
                    'price/code/rarity': (old, val) => `Price/Code/Rarity changed`,
                    'weekly': (old, val) => val ? 'âœ“ Added to Weekly Shop' : 'âœ— Removed from Weekly Shop',
                    'weeklystar': (old, val) => val ? 'âœ“ Added to Star Shop' : 'âœ— Removed from Star Shop',
                    'new': (old, val) => val ? 'âœ“ Marked as New' : 'âœ— Unmarked as New',
                    'retired': (old, val) => val ? 'âœ“ Marked as Retired' : 'âœ— Unmarked as Retired',
                    'removed': (old, val) => val ? 'âœ“ Marked as Removed' : 'âœ— Unmarked as Removed',
                    'premium': (old, val) => val ? 'âœ“ Marked as Premium' : 'âœ— Unmarked as Premium',
                    'tradable': (old, val) => !val ? 'âœ“ Marked as Untradable' : 'âœ— Marked as Tradable',
                    'name': (old, val) => `Name: "${old}" â†’ "${val}"`,
                    'demand': (old, val) => {
                        const labels = ['Terrible', 'Bad', 'Okay', 'Good', 'Great', 'Amazing'];
                        const oldLabel = labels[old || 0];
                        const newLabel = labels[val || 0];
                        return `Demand: ${oldLabel} (${old || 0}â˜…) â†’ ${newLabel} (${val || 0}â˜…)`;
                    }
                };

                return formatters[field] ? formatters[field](oldValue, newValue) : `${field}: ${oldValue} â†’ ${newValue}`;
            },

            // Show the publish preview modal
            async showPublishModal() {
                const changes = this.generateChangeSummary();
                const totalChanges = changes.modified.length + changes.added.length + changes.removed.length;

                if (totalChanges === 0) {
                    ErrorHandler.showToast('No changes to publish', 'error');
                    return;
                }

                // Create modal
                const modal = this.createModal(changes, totalChanges);
                document.body.appendChild(modal);

                // Animate in
                requestAnimationFrame(() => {
                    modal.style.opacity = '1';
                    DOM.get('publishModalContent').style.transform = 'scale(1)';
                });
            },

            createModal(changes, totalChanges) {
                const modal = document.createElement('div');
                modal.className = 'publish-modal-overlay';
                modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            backdrop-filter: blur(4px);
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;

                const content = document.createElement('div');
                content.className = 'delete-modal';
                content.id = "publishModalContent";
                content.style.cssText = `
            max-width: 90%;
            width: 600px;
            padding: 0px;
            overflow: clip;
        `;

                // Header
                const header = document.createElement('div');
                header.style.cssText = `
            padding: 20px;
            border-bottom: 1px solid var(--shade, #374151);
            background: linear-gradient(135deg, rgb(255 255 255 / 10%), rgb(39 118 215 / 10%));
        `;
                header.innerHTML = `
            <h2 style="margin: 0; font-size: 24px; color: white; display: flex; align-items: center; gap: 10px;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="12" y1="18" x2="12" y2="12"></line>
                    <line x1="9" y1="15" x2="15" y2="15"></line>
                </svg>
                Review Changes
            </h2>
            <p style="margin: 8px 0 0 0; color: #9ca3af;">
                ${totalChanges} change${totalChanges !== 1 ? 's' : ''} ready to publish
            </p>
        `;

                // Body with changes list
                const body = document.createElement('div');
                body.style.cssText = `
            flex: 1;
            overflow-y: auto;
            padding: 20px 20px 0px;
            max-height: 400px;
        `;
                body.innerHTML = this.renderChanges(changes);

                // Footer with actions
                const footer = document.createElement('div');
                footer.style.cssText = `
            border-top: 1px solid var(--shade, #374151);
            display: flex;
            gap: 12px;
            padding: 17px;
            justify-content: flex-end;
            align-items: center;
        `;

                // Version conflict warning (hidden by default)
                const conflictWarning = document.createElement('div');
                conflictWarning.id = 'conflict-warning';
                conflictWarning.style.cssText = `
            flex: 1;
            color: #fbbf24;
            display: none;
            font-size: 14px;
            align-items: center;
            gap: 8px;
        `;
                conflictWarning.innerHTML = `
            <span style="display: flex; align-items: center; gap: 6px;">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                    <line x1="12" y1="9" x2="12" y2="13"></line>
                    <line x1="12" y1="17" x2="12.01" y2="17"></line>
                </svg>
                Newer version exists
            </span>
            <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                <input type="checkbox" id="force-overwrite" style="cursor: pointer;">
                <span style="font-size: 13px;">Force overwrite</span>
            </label>
        `;

                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.className = 'small-btn ghost';
                cancelBtn.onclick = () => this.closeModal(modal);

                const publishBtn = document.createElement('button');
                publishBtn.textContent = 'Publish Changes';
                publishBtn.className = 'small-btn';
                publishBtn.onclick = () => this.handlePublish(modal);

                footer.appendChild(conflictWarning);
                footer.appendChild(cancelBtn);
                footer.appendChild(publishBtn);

                content.appendChild(header);
                content.appendChild(body);
                content.appendChild(footer);
                modal.appendChild(content);

                // Close on backdrop click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closeModal(modal);
                    }
                });

                // Close on Escape key
                const escHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.closeModal(modal);
                        document.removeEventListener('keydown', escHandler);
                    }
                };
                document.addEventListener('keydown', escHandler);

                return modal;
            },

            renderChanges(changes) {
                let html = '';

                // Added items (show first for better visibility)
                if (changes.added.length > 0) {
                    html += `<div style="margin-bottom: 24px;">
                <h3 style="color: #10b981; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="16"></line>
                        <line x1="8" y1="12" x2="16" y2="12"></line>
                    </svg>
                    New Items (${changes.added.length})
                </h3>
                <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); 
                            border-radius: 8px; padding: 12px;">`;

                    changes.added.forEach(item => {
                        html += `<div style="color: #d1d5db; margin: 4px 0;">â€¢ ${item.name}</div>`;
                    });

                    html += `</div></div>`;
                }

                // Modified items
                if (changes.modified.length > 0) {
                    html += `
                <div style="margin-bottom: 24px;">
                    <h3 style="color: #fbbf24; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                        </svg>
                        Modified Items (${changes.modified.length})
                    </h3>`;

                    changes.modified.forEach(item => {
                        html += `<div style="background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); 
                        border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: white;">
                        ${item.name}
                    </div>
                    <ul style="margin: 0; padding-left: 20px; color: #d1d5db; font-size: 14px;">`;

                        item.changes.forEach(change => {
                            html += `<li style="margin: 4px 0;">${change.display}</li>`;
                        });

                        html += `</ul></div>`;
                    });

                    html += '</div>';
                }

                // Removed items
                if (changes.removed.length > 0) {
                    html += `
                <div style="margin-bottom: 24px;">
                    <h3 style="color: #ef4444; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="8" y1="12" x2="16" y2="12"></line>
                        </svg>
                        Removed Items (${changes.removed.length})
                    </h3>
                    <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); 
                                border-radius: 8px; padding: 12px;">`;

                    changes.removed.forEach(item => {
                        html += `<div style="color: #d1d5db; margin: 4px 0;">â€¢ ${item.name}</div>`;
                    });

                    html += `</div></div>`;
                }

                return html || '<p style="color: #9ca3af;">No changes to display</p>';
            },

            async handlePublish(modal) {
                UpdateChecker.stop();
                const publishBtn = modal.querySelector('button:last-child');
                const conflictWarning = modal.querySelector('#conflict-warning');
                const forceCheckbox = modal.querySelector('#force-overwrite');

                publishBtn.disabled = true;
                publishBtn.textContent = 'Publishing...';

                try {
                    const response = await API.saveData();

                    if (response.status === 409) {
                        // Version conflict detected
                        conflictWarning.style.display = 'flex';
                        publishBtn.textContent = 'Retry Publish';
                        publishBtn.disabled = false;

                        if (forceCheckbox && forceCheckbox.checked) {
                            // Force overwrite
                            const forceResponse = await fetch(CONFIG.API_URLS.UPDATE_GIST, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    content: state.jsData,
                                    username: state.adminName,
                                    version: state.gistVersion,
                                    force: true
                                })
                            });

                            if (forceResponse.ok) {
                                this.showSuccess(modal);
                                setTimeout(() => location.reload(), 3500);
                            } else {
                                const errorData = await forceResponse.text();
                                throw new Error(errorData || 'Force save failed');
                            }
                        }
                    } else if (response.ok) {
                        // Clear change tracking after successful publish
                        ChangeTracker.initializeOriginals();

                        this.showSuccess(modal);
                        setTimeout(() => location.reload(), 3500);
                    } else {
                        // Handle non-OK responses
                        const errorData = await response.text();
                        throw new Error(errorData || `Server error: ${response.status}`);
                    }
                } catch (error) {
                    // Show proper error modal instead of just a toast
                    this.showErrorModal(modal, error.message);
                    publishBtn.disabled = false;
                    publishBtn.textContent = 'Retry Publish';
                }
            },

            showErrorModal(currentModal, errorMessage) {
                // Hide the current modal content
                const content = currentModal.querySelector('.delete-modal') || DOM.get('publishModalContent');

                // Create error display
                content.innerHTML = `
            <div style="padding: 40px; text-align: center;">
                <div style="font-size: 64px; margin-bottom: 20px; display: flex; justify-content: center;">
                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10" fill="#ef444420"></circle>
                        <line x1="15" y1="9" x2="9" y2="15"></line>
                        <line x1="9" y1="9" x2="15" y2="15"></line>
                    </svg>
                </div>
                <h2 style="color: #ef4444; margin: 0 0 12px 0;">Publish Failed</h2>
                <div style="background: rgba(239, 68, 68, 0.1); 
                            border: 1px solid rgba(239, 68, 68, 0.3); 
                            border-radius: 8px; 
                            padding: 16px; 
                            margin: 20px 0;
                            text-align: left;">
                    <strong style="color: #fbbf24;">Error Details:</strong>
                    <p style="color: #d1d5db; margin: 8px 0 0 0; word-break: break-word;">
                        ${Utils.escapeHtml(errorMessage)}
                    </p>
                </div>
                <div style="display: flex; gap: 12px; justify-content: center; margin-top: 24px;">
                    <button class="small-btn ghost" onclick="location.reload()">
                        Refresh Page
                    </button>
                    <button class="small-btn" onclick="this.closest('.publish-modal-overlay').remove()">
                        Close & Try Again
                    </button>
                </div>
                <p style="color: #9ca3af; margin: 16px 0 0 0; font-size: 12px;">
                    Your changes have not been lost. You can try publishing again.
                </p>
            </div>`;
            },

            showSuccess(modal) {
                const content = DOM.get('publishModalContent');
                content.innerHTML = `
            <div style="padding: 60px; text-align: center;">
                <div style="font-size: 64px; margin-bottom: 20px; display: flex; justify-content: center;">
                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10" fill="#10b98120"></circle>
                        <polyline points="9 11 12 14 15 10"></polyline>
                    </svg>
                </div>
                <h2 style="color: white; margin: 0 0 12px 0;">Changes Published!</h2>
                <p style="color: #9ca3af;">The catalog has been updated successfully.</p>
            </div>`;
            },

            closeModal(modal) {
                DOM.get('publishModalContent').style.transform = 'scale(0.9)';
                modal.style.opacity = '0';
                setTimeout(() => modal.remove(), 300);
            },

            // Initialize - replace the current publish button handler
            init() {
                const publishBtn = DOM.get('publish-btn');
                if (!publishBtn) return;

                // Remove old handler and add new one
                const newBtn = publishBtn.cloneNode(true);
                publishBtn.parentNode.replaceChild(newBtn, publishBtn);

                newBtn.addEventListener('click', () => {
                    this.showPublishModal();
                });

                // Update the button text to indicate new behavior
                newBtn.innerHTML = '<span class="rocket-icon"></span><span class="publish-label">Review & Publish</span>';
            }
        };
        // ============================
        // Enhanced Error Handling
        // ============================
        const ErrorHandler = {
            handle(error, context = '') {
                console.error(`Error in ${context}:`, error);

                // Show user-friendly error message
                this.showToast(`Error: ${error.message || 'Something went wrong'}`, 'error');
            },

            showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.textContent = message;
                toast.style.cssText = `

                    background: ${type === 'error' ? 'linear-gradient(135deg, #ef4444, #c62828)' : type === 'success' ? 'linear-gradient(135deg, #10b981, #0b8045)' : 'linear-gradient(135deg, #3b82f6, #1e40af)'};
                    z-index: 110000;
                `;

                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            }
        };

        // ============================
        // Authentication (Roblox Auth)
        // ============================
        const Auth = {
            userData: null,
            authToken: null,
            session: null,


            async init() {
                if (DEV_MODE.enabled) {
                    console.log('ðŸš€ Running in development mode');
                    state.adminName = DEV_MODE.adminName;
                    return this.onSuccess();
                }

                // Check for OAuth callback
                const urlParams = new URLSearchParams(window.location.search);
                const authSuccess = urlParams.get('auth_success');
                const authToken = urlParams.get('token');
                const authError = urlParams.get('auth_error');

                if (authSuccess && authToken) {
                    // OAuth login successful
                    localStorage.setItem('auth_token', authToken);
                    // Clean URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                    // Will be checked by checkExistingAuth
                } else if (authError) {
                    // OAuth login failed
                    this.showError(`Authentication failed: ${authError}`);
                    // Clean URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                }

                this.loadAuthUI();
                this.checkExistingAuth();
            },

            loadAuthUI() {
                const container = DOM.get("auth-container");
                container.innerHTML = `
                    <div class="auth-status" id="admin-auth-status">
                        <button class="auth-login-btn" id="admin-auth-oauth-btn" style="background: #3964ff; border:0px solid #3964ff; margin-bottom: 10px;">
                            <svg style="rotate: 35deg;width: 20px;margin: 0px 5px -4px 0px;" viewBox="0 0 134 134"><path fill="currentcolor" stroke-linejoin="round" stroke-width="12" d="m 134 106 l -103.9 27.8 l -27.9 -104 l 104 -27.9 z m -50 -30 l -25.1 6.7 l -6.7 -25.1 l 25.1 -6.7 z" fill-rule="evenodd"></path></svg>
                            Sign in with Roblox
                        </button>
                        <p style="font-size: 12px; color: var(--text-secondary); margin: 8px 0;">Faster and more secure</p>

                        <div style="margin: 15px 0; display: flex; align-items: center; gap: 10px;">
                            <div style="flex: 1; height: 1px; background: var(--text-secondary); opacity: 0.3;"></div>
                            <span style="color: var(--text-secondary); font-size: 12px;">OR</span>
                            <div style="flex: 1; height: 1px; background: var(--text-secondary); opacity: 0.3;"></div>
                        </div>

                        <button class="auth-login-btn" id="admin-auth-login-btn">Use In-Game Code</button>
                        <div id="admin-auth-code-display" style="display: none; margin-top: 15px;">
                            <p style="margin-bottom: 10px; color: var(--text-secondary);">Enter this code in Epic Minigames:</p>
                            <div style="font-size: 2.5rem; font-weight: bold; letter-spacing: 0.15em; padding: 20px; background: var(--bg-item); border-radius: 12px; margin-bottom: 15px; border: 2px solid var(--border-color);">
                                <span id="admin-auth-code">------</span>
                            </div>
                            <p style="font-size: 0.95rem; color: var(--text-secondary); margin-bottom: 10px;">
                                Go to <a href="https://www.roblox.com/games/122649225404413/EMWIKI-Account-Linker" target="_blank" style="color: #4caf50; text-decoration: underline;">EMWIKI Account Linker</a>
                                and type this code in the prompt
                            </p>
                            <div id="admin-auth-timer" style="color: var(--text-secondary); font-weight: 600;"></div>
                        </div>
                    </div>
                `;

                const oauthBtn = DOM.get("admin-auth-oauth-btn");
                if (oauthBtn) {
                    oauthBtn.addEventListener("click", () => this.loginWithOAuth());
                }

                const loginBtn = DOM.get("admin-auth-login-btn");
                if (loginBtn) {
                    loginBtn.addEventListener("click", () => this.startLogin());
                }
            },

            loginWithOAuth() {
                window.location.href = '/api/auth/oauth/authorize';
            },

            async checkExistingAuth() {
                const token = localStorage.getItem("auth_token");
                if (!token) return;

                try {
                    const response = await fetch("/api/auth/session", {
                        headers: { "Authorization": `Bearer ${token}` }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        const roles = data.role || '["user"]';

                        if (roles.includes("admin") || roles.includes("moderator")) {
                            this.authToken = token;
                            this.session = token;
                            this.userData = data;
                            state.adminName = data.displayName || data.username;
                            this.onSuccess();
                        } else {
                            DOM.get("admin-auth-login-btn").innerText = "LOGOUT";
                            DOM.get("admin-auth-login-btn").style.background = "linear-gradient(180deg, #ff4444, #930000)";
                            DOM.get("admin-auth-login-btn").style.border = "1px solid #f95151";
                            DOM.get("admin-auth-login-btn").onClick = () => {
                                fetch("/api/logout", { method: "POST" }).finally(() => {
                                    localStorage.removeItem("auth_token");
                                    location.reload();

                                });
                            };
                            this.showError("Access Denied: You do not have permission to access this panel, FUCK OFF!");

                        }
                    } else {
                        console.log('poop')
                    }
                } catch (err) {
                    console.error("Auth check failed:", err);
                }
            },

            async startLogin() {
                try {
                    const response = await fetch("/api/auth/generate-code", {
                        method: "POST"
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || "Failed to generate code");
                    }

                    const { code, expiresIn } = await response.json();
                    this.showCodeDisplay(code, expiresIn);
                    this.pollForVerification(code);
                } catch (err) {
                    this.showError("Failed to generate login code. " + err.message);
                    console.error("Login error:", err);
                }
            },

            showCodeDisplay(code, expiresIn) {
                const loginBtn = DOM.get("admin-auth-login-btn");
                const codeDisplay = DOM.get("admin-auth-code-display");
                const codeEl = DOM.get("admin-auth-code");

                if (loginBtn) loginBtn.style.display = "none";
                if (codeDisplay) codeDisplay.style.display = "block";
                if (codeEl) codeEl.textContent = code;

                let timeLeft = expiresIn;
                const timerEl = DOM.get("admin-auth-timer");
                this.timerInterval = setInterval(() => {
                    timeLeft--;
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    if (timerEl) timerEl.textContent = `Expires in ${minutes}:${seconds.toString().padStart(2, '0')}`;

                    if (timeLeft <= 0) {
                        clearInterval(this.timerInterval);
                        this.showError("Code expired. Please try again.");
                        this.resetAuthUI();
                    }
                }, 1000);
            },

            async pollForVerification(code) {
                const maxAttempts = 60;
                let attempts = 0;

                const poll = async () => {
                    if (attempts >= maxAttempts) {
                        return;
                    }

                    try {
                        const response = await fetch('/api/auth/check-code', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ code })
                        });
                        if (response.ok) {
                            const data = await response.json();
                            if (data.verified && data.token) {
                                clearInterval(this.timerInterval);
                                const roles = JSON.parse(data.user.role || '["user"]');
                                localStorage.setItem("auth_token", data.token);
                                if (roles.includes("admin") || roles.includes("moderator")) {
                                    
                                    this.authToken = data.token;
                                    this.session = data.token;
                                    this.userData = data.user;
                                    state.adminName = data.user.display_name || data.user.username;
                                    this.onSuccess();
                                } else {
                                    DOM.get("admin-auth-login-btn").innerText = "LOGOUT";
                                    DOM.get("admin-auth-login-btn").style.background = "linear-gradient(180deg, #ff4444, #930000)";
                                    DOM.get("admin-auth-login-btn").style.border = "1px solid #f95151";
                                    DOM.get("admin-auth-login-btn").onClick = () => {
                                        fetch("/api/logout", { method: "POST" }).finally(() => {
                                            localStorage.removeItem("auth_token");
                                            location.reload();

                                        });
                                    };

                                    this.showError("Access Denied: You do not have permission to access this panel, FUCK OFF!");
                                    this.resetAuthUI();
                                }
                                return;
                            }
                        }
                    } catch (err) {
                        console.error("Poll error:", err);
                    }

                    attempts++;
                    setTimeout(poll, 5000);
                };

                poll();
            },

            showError(message) {
                const errorDiv = DOM.get("login-error");
                if (errorDiv) {
                    errorDiv.textContent = message;
                    errorDiv.style.color = "#f44336";
                    errorDiv.style.marginTop = "15px";
                    errorDiv.style.padding = "10px";
                    errorDiv.style.background = "rgba(244, 67, 54, 0.1)";
                    errorDiv.style.borderRadius = "6px";
                }

                DOM.query(".login-card").classList.add("shake");
                setTimeout(() => DOM.query(".login-card").classList.remove("shake"), 500);
            },

            resetAuthUI() {
                if (this.timerInterval) clearInterval(this.timerInterval);
                const loginBtn = DOM.get("admin-auth-login-btn");
                const codeDisplay = DOM.get("admin-auth-code-display");
                if (loginBtn) loginBtn.style.display = "block";
                if (codeDisplay) codeDisplay.style.display = "none";
            },

            async onSuccess() {
                this.showWelcome();
                await App.init();
            },

            showWelcome() {
                CanvasArrow.enabled = false;
                DOM.query("main").style.display = "flex";
                DOM.query("header").style.display = "flex";
                const overlay = DOM.get("login-overlay");
                const welcomeLabel = DOM.get("welcome-label");
                const text = `Welcome, ${state.adminName}.`;

                overlay.style.background = "transparent";
                overlay.style.pointerEvents = "none";
                DOM.query(".garagedoor").remove();
                DOM.query(".login-card").classList.add("glass");
                welcomeLabel.style.opacity = "1";

                let i = 0;
                setTimeout(() => {
                    DOM.query(".login-card").style.backdropFilter = "url(#frosted)";
                    DOM.query(".login-card").style.webkitBackdropFilter = "url(#frosted)";
                }, 1000);

                const typeInterval = setInterval(() => {
                    if (i < text.length) {
                        welcomeLabel.textContent += text[i];
                        i++;
                    } else {
                        DOM.query(".login-card").addEventListener("animationend", () => {
                            DOM.query(".login-card").style.animation = "unset";
                        });
                        clearInterval(typeInterval);
                        setTimeout(() => DOM.query(".login-card").classList.add("bobble"), 2400);
                    }
                }, 40);
            },
        };

        // ============================
        // Main App
        // ============================
        const App = {
            async init() {
                // Load data
                const loaded = await API.loadData();
                if (!loaded) {
                    ErrorHandler.showToast('Failed to load data. Please refresh.', 'error');
                    return;
                }

                // Initialize change tracking with original data
                ChangeTracker.initializeOriginals();

                // Initialize WebSockets
                this.initWebSockets();

                // Setup UI
                UI.renderFilterControls();
                UI.renderShops();
                UI.renderItems();
                if (!isTouch) {
                    UI.setupDragDrop();
                    CanvasArrow.init();
                }

                // Load history
                HistoryManager.load();

                // Initialize components
                NotesManager.init();
                PanelsManager.init();
                PublishManager.init();
                UndoRedoManager.init();
                ItemAdder.init();
                GalleryMod.init();
                UserManagement.init();
                this.initEventListeners();
                UpdateChecker.start();

                setTimeout(() => DraggablePanelManager.init(), 100);


            },

            initWebSockets() {
                // Admin tracker
                state.ws.admin = new WebSocketManager(
                    `${CONFIG.WS_URLS.ADMIN_TRACKER}?adminName=${encodeURIComponent(state.adminName)}`,
                    'admin',
                    {
                        onOpen: () => {
                            ErrorHandler.showToast('Status: Online', 'success');
                        },
                        onMessage: (data) => {
                            if (data.type === 'adminList') {
                                App.updateAdminOnline(data.admins);
                            }
                        },
                        onClose: () => {
                            ErrorHandler.showToast('Status: Offline', 'error');
                        }
                    }
                );

                // In the initWebSockets() method, update the notes WebSocket handler:
                state.ws.notes = new WebSocketManager(
                    CONFIG.WS_URLS.NOTES_BOARD,
                    'notes',
                    {
                        onMessage: (msg) => {
                            if (msg.type === 'init') {
                                state.notes = msg.notes || [];
                                NotesManager.render();
                            } else if (msg.type === 'create') {
                                // Check if note already exists to prevent duplicates
                                if (!state.notes.find(n => n.id === msg.note.id)) {
                                    state.notes.push(msg.note);
                                    NotesManager.render();
                                }
                            } else if (msg.type === 'delete') {
                                state.notes = state.notes.filter(n => n.id !== msg.id);
                                NotesManager.render();
                            } else if (msg.type === 'react') {
                                // Handle reaction updates
                                const noteIndex = state.notes.findIndex(n => n.id === msg.noteId);
                                if (noteIndex !== -1) {
                                    state.notes[noteIndex].reactions = msg.reactions || {};
                                    NotesManager.render();
                                }
                            }
                        },
                        onClose: () => {
                            ErrorHandler.showToast('Notes: Offline', 'error');
                        }
                    }
                );
            },

            updateAdminOnline(admins) {
                const container = DOM.get('admin-online');
                container.innerHTML = '';
                const now = Date.now();

                admins.forEach(admin => {
                    const pill = Utils.createElement('div', {
                        style: {
                            display: 'flex',
                            alignItems: 'center',
                            gap: '6px',
                            padding: '4px 10px',
                            borderRadius: '20px',
                            fontSize: '14px',
                            fontWeight: '500',
                            color: '#fff',
                            background: admin === state.adminName ?
                                'rgba(100, 100, 255, 0.4)' :
                                'rgba(255, 255, 255, 0.05)'
                        }
                    });

                    if (admin !== state.adminName) {
                        const dot = Utils.createElement('span', {
                            style: {
                                width: '10px',
                                height: '10px',
                                borderRadius: '50%',
                                display: 'inline-block',
                                backgroundColor: 'limegreen'
                            }
                        });
                        pill.appendChild(dot);
                    }

                    pill.appendChild(document.createTextNode(admin));
                    container.appendChild(pill);
                });
            },

            initEventListeners() {
                // Settings
                DOM.get('settings-btn').addEventListener('click', () => {
                    DOM.query('.menu').classList.toggle('show');
                });

                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!DOM.get('settings-menu').contains(e.target) && e.target !== DOM.get('settings-btn')) {
                        DOM.get('settings-menu').classList.remove('show');
                    }
                });

                // Theme
                DOM.get('theme-select').addEventListener('change', (e) => {
                    document.body.setAttribute('data-theme', e.target.value);
                });

                // Download JSON
                DOM.get('download-json').addEventListener('click', () => {
                    const blob = new Blob([JSON.stringify(state.jsData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = Utils.createElement('a', {
                        href: url,
                        download: 'EMWIKI-Exported-' + new Date().toISOString().slice(0, 10) + '.json'
                    });
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);
                });

                DOM.get('import-json').addEventListener('click', () => {
                    // Check for unsaved changes
                    const changes = ChangeTracker.getAllChanges();
                    if (changes.hasChanges) {
                        if (!confirm('You have unsaved changes that will be lost. Continue with import?')) {
                            return;
                        }
                    }

                    // Trigger file input
                    DOM.get('json-file-input').click();
                });

                // File input change handler
                DOM.get('json-file-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];

                    if (file) {
                        await JSONImportManager.importJSON(file);

                        // Clear the input so the same file can be selected again
                        e.target.value = '';
                    }
                });



                // Logout
                DOM.get("logout").addEventListener("click", async () => {

                    // Clear session cookie via backend
                    fetch("/api/logout", { method: "POST" }).finally(() => {
                        localStorage.removeItem("auth_token");
                        location.reload();

                    });

                });




                // Quick editor close
                DOM.get('quick-editor-close').addEventListener('click', () => {
                    QuickEditor.close();
                });


            }
        };

        // ============================
        // Update Checker
        // ============================
        const UpdateChecker = {
            intervalId: null,
            updatePending: false,

            start() {
                // Clear any existing interval
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                }

                this.intervalId = setInterval(() => this.check(), 10000);
            },

            stop() {
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
            },

            hasUnsavedChanges() {
                // Check if there are any changed items
                return state.changedItems && state.changedItems.size > 0;
            },

            async check() {
                try {
                    const res = await fetch(CONFIG.API_URLS.LATEST_VERSION, { cache: 'no-store' });
                    if (!res.ok) return;

                    const text = await res.text();
                    if (!text.includes('@') || !text.includes('|')) return;

                    const [userPart, versionPart] = text.split('@');
                    const [, newVersion] = versionPart.split('|');
                    const updatedBy = userPart.trim();

                    // Check if version changed
                    if (state.currentVersion !== newVersion && !this.updatePending) {
                        this.updatePending = true;
                        this.handleUpdate(updatedBy.slice(0, -1), newVersion);
                    }
                } catch (err) {
                    console.error(`Update check failed: ${err}`);
                }
            },

            handleUpdate(updatedBy, newVersion) {
                // Check for unsaved changes
                if (this.hasUnsavedChanges()) {
                    this.showUpdateModal(updatedBy, newVersion);
                } else {
                    // No unsaved changes, safe to reload
                    ErrorHandler.showToast(
                        `ðŸ“¦ New catalog update by ${updatedBy}. Reloading in 5 seconds...`,
                        'info'
                    );

                    this.scheduleReload(5000);
                }
            },

            showUpdateModal(updatedBy, newVersion) {
                // Create modal for unsaved changes warning
                const modal = document.createElement('div');
                modal.className = 'update-warning-modal';
                modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #0000003d;
                border: 2px solid rgb(251, 191, 36);
                border-radius: 12px;
                padding: 9px 24px 24px;
                z-index: 10001;
                max-width: 400px;
                box-shadow: rgba(0, 0, 0, 0.5) 0px 20px 60px, rgba(251, 191, 36, 0.2) 0px 0px 40px;
                backdrop-filter: blur(51px);
                    `;

                modal.innerHTML = `
            <h3 style="color: #fbbf24;
    margin: 0 0 12px 0;
    display: flex;
    align-items: center;
    font-variant: all-petite-caps;
    gap: 8px;
    font-size: 25px;">
                âš ï¸ Catalog Update Available
            </h3>
            <p style="color: #d1d5db; margin: 0 0 8px 0;">
                <strong>${updatedBy}</strong> has updated the catalog.
            </p>
            <p style="color: #ef4444; margin: 0 0 16px 0; font-weight: 500;">
                You have ${state.changedItems.size} unsaved change${state.changedItems.size !== 1 ? 's' : ''} that will be lost!
            </p>
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
                <button id="save-first-btn" class="small-btn">
                    Save My Changes First
                </button>
                <button id="discard-btn" class="small-btn danger">
                    Discard & Reload
                </button>
                <button id="cancel-update-btn" class="small-btn ghost">
                    Stay on This Version
                </button>
            </div>
            <p style="color: #9ca3af; margin: 12px 0 0 0; font-size: 12px;">
                <span id="countdown">Auto-reload paused</span> â€¢ Version: ${newVersion}
            </p>
        `;

                document.body.appendChild(modal);

                // Button handlers
                document.getElementById('save-first-btn').onclick = async () => {
                    modal.remove();

                    // Show publish modal
                    if (typeof PublishManager !== 'undefined') {
                        PublishManager.showPublishModal();
                    } else {
                        // Fallback to direct save
                        const response = await API.saveData();
                        if (response.ok) {
                            ErrorHandler.showToast('Changes saved! Reloading...', 'success');
                            setTimeout(() => location.reload(), 1500);
                        }
                    }
                };

                document.getElementById('discard-btn').onclick = () => {
                    if (confirm('Are you sure? All unsaved changes will be lost.')) {
                        modal.remove();
                        this.forceReload();
                    }
                };

                document.getElementById('cancel-update-btn').onclick = () => {
                    modal.remove();
                    this.updatePending = false;

                    // Show persistent notification
                    this.showUpdateBadge(updatedBy);

                    ErrorHandler.showToast('Update postponed. Refresh when ready.', 'info');
                };
            },

            scheduleReload(delay) {
                // Create countdown toast
                let remaining = Math.ceil(delay / 1000);
                const toastId = 'reload-countdown';

                const countdown = setInterval(() => {
                    remaining--;

                    if (remaining > 0) {
                        // Update countdown
                        const existingToast = document.getElementById(toastId);
                        if (existingToast) {
                            existingToast.textContent = `Reloading in ${remaining}...`;
                        }
                    } else {
                        clearInterval(countdown);
                        this.forceReload();
                    }
                }, 1000);

                // Allow cancellation
                setTimeout(() => {
                    const toast = document.getElementById(toastId);
                    if (toast) {
                        toast.style.cursor = 'pointer';
                        toast.onclick = () => {
                            clearInterval(countdown);
                            toast.remove();
                            this.updatePending = false;
                            ErrorHandler.showToast('Reload cancelled', 'info');
                        };
                    }
                }, 100);
            },

            forceReload() {
                // Try hard reload first, fallback to normal reload
                try {
                    location.reload(true);
                } catch (e) {
                    location.reload();
                }
            },

            showUpdateBadge(updatedBy) {
                // Add a persistent badge to header
                const header = document.querySelector('header');
                if (!header) return;

                // Remove existing badge if any
                const existing = document.getElementById('update-badge');
                if (existing) existing.remove();

                const badge = document.createElement('div');
                badge.id = 'update-badge';
                badge.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: #1f2937;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            z-index: 9999;
            animation: pulse 2s infinite;
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
        `;
                badge.innerHTML = `ðŸ“¦ Update available from ${updatedBy}`;
                badge.title = 'Click to reload';
                badge.onclick = () => {
                    if (this.hasUnsavedChanges()) {
                        this.handleUpdate(updatedBy, state.currentVersion);
                    } else {
                        this.forceReload();
                    }
                };

                document.body.appendChild(badge);
            }
        };

        // ============================
        // Canvas Arrow Animation
        // ============================
        const CanvasArrow = {
            canvas: null,
            ctx: null,
            mouse: { x: null, y: null },
            target: null,
            enabled: true,

            init() {
                this.canvas = DOM.get('overlay');
                this.ctx = this.canvas.getContext('2d');
                this.updateSize();

                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });

                this.animate();
            },

            updateSize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            },

            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.enabled && this.target && this.mouse.x && this.mouse.y) {
                    this.drawArrow();
                }

                requestAnimationFrame(() => this.animate());
            },

            drawArrow() {
                const rect = this.target.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;

                const angle = Math.atan2(cy - this.mouse.y, cx - this.mouse.x);
                const x1 = cx - Math.cos(angle) * (rect.width / 2 + 12);
                const y1 = cy - Math.sin(angle) * (rect.height / 2 + 12);

                const midX = (this.mouse.x + x1) / 2;
                const midY = (this.mouse.y + y1) / 2;
                const offset = Math.min(200, Math.hypot(x1 - this.mouse.x, y1 - this.mouse.y) * 0.5);
                const t = Math.max(-1, Math.min(1, (this.mouse.y - y1) / 200));
                const controlX = midX;
                const controlY = midY + offset * t;

                const distance = Math.sqrt((x1 - this.mouse.x) ** 2 + (y1 - this.mouse.y) ** 2);
                const opacity = Math.min(0.75, (distance - Math.max(rect.width, rect.height) / 4) / 750);

                this.ctx.strokeStyle = `rgba(255,255,255,${opacity})`;
                this.ctx.lineWidth = 1;

                // Draw curve
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.moveTo(this.mouse.x, this.mouse.y);
                this.ctx.quadraticCurveTo(controlX, controlY, x1, y1);
                this.ctx.setLineDash([10, 4]);
                this.ctx.stroke();
                this.ctx.restore();

                // Draw arrowhead
                const headAngle = Math.atan2(y1 - controlY, x1 - controlX);
                const headLength = 10;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(
                    x1 - headLength * Math.cos(headAngle - Math.PI / 6),
                    y1 - headLength * Math.sin(headAngle - Math.PI / 6)
                );
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(
                    x1 - headLength * Math.cos(headAngle + Math.PI / 6),
                    y1 - headLength * Math.sin(headAngle + Math.PI / 6)
                );
                this.ctx.stroke();
            }
        };

        // ============================
        // Enhanced Draggable Panel Manager
        // ============================
        const DraggablePanelManager = {
            // Configuration
            config: {
                WIDTH_THRESHOLD: 1300,
                MOBILE_THRESHOLD: 768, // Add mobile detection threshold
                SNAP_MARGIN: 12,
                STORAGE_KEY: 'quickEditorPosV1',
                SIDEBAR_TOP: 96,
                EXCLUDED_TAGS: ['INPUT', 'TEXTAREA', 'BUTTON', 'SELECT', 'SPAN', 'LI']
            },

            // State
            state: {
                dragging: false,
                startX: 0,
                startY: 0,
                startLeft: 0,
                startTop: 0,
                observer: null,
                contentObserver: null,
                isInitialized: false,
                currentMode: null, // Track current mode: 'sidebar', 'modal', or 'mobile'
                isMobile: false
            },

            // DOM elements (cached)
            elements: {
                modal: null,
                panel: null,
                handle: null,
                closeBtn: null,
                mainEl: null,
                spacer: null,
                originalParent: null
            },

            // Initialize the draggable panel system
            init() {
                if (this.state.isInitialized) return;

                try {
                    this.cacheElements();
                    if (!this.elements.modal || !this.elements.panel) {
                        console.warn('Draggable panel elements not found');
                        return false;
                    }

                    // Check if mobile
                    this.checkMobile();

                    this.setupEventListeners();
                    this.setupObserver();
                    this.handleResize();

                    this.state.isInitialized = true;
                    return true;
                } catch (error) {
                    console.error('Failed to initialize draggable panel:', error);
                    return false;
                }
            },

            // Add mobile detection
            checkMobile() {
                this.state.isMobile = window.innerWidth <= this.config.MOBILE_THRESHOLD &&
                    ('ontouchstart' in window && navigator.maxTouchPoints > 0);
            },

            // Add mobile mode handler
            switchToMobileMode() {
                const { panel, modal, closeBtn, spacer } = this.elements;
                // Set current mode
                this.state.currentMode = 'mobile';

                // Stop observing content changes in mobile mode
                this.stopContentObserver();

                // Move panel back to modal if needed
                if (!modal.contains(panel)) {
                    modal.appendChild(panel);
                }

                // Apply mobile full-screen styles
                Object.assign(modal.style, {
                    position: 'fixed',
                    top: '0',
                    left: '0',
                    width: '100%',
                    height: '100%',
                    zIndex: '9999',
                    background: 'var(--bg-color, #1f2937)',
                    display: 'flex',
                    flexDirection: 'column'
                });

                Object.assign(panel.style, {
                    position: 'relative',
                    width: '100%',
                    height: '100%',
                    maxWidth: '-webkit-fill-available',
                    maxHeight: '100%',
                    top: 'unset',
                    left: 'unset',
                    transform: 'none',
                    boxShadow: 'none',
                    border: 'none',
                    background: 'transparent',
                    overflow: 'hidden',
                    display: 'flex',
                    flexDirection: 'row',
                    justifyContent: 'center',
                    alignItems: 'space-between',
                    alignContent: 'center'

                });

                // Style the close button for mobile
                if (closeBtn) {
                    Object.assign(closeBtn.style, {
                        position: 'fixed',
                        top: '72px',
                        right: '10px',
                        zIndex: '10000',
                        width: '40px',
                        height: '40px',
                        fontSize: '34px',
                        background: 'rgba(0, 0, 0, 0.5)',
                        borderRadius: '50%',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center'
                    });
                }

                // Hide spacer
                if (spacer) {
                    spacer.style.display = 'none';
                }

                // Adjust quick editor content for mobile
                this.adjustMobileContent();
            },

            adjustMobileContent() {
                const { panel } = this.elements;
                if (!panel) return;

                // Find and adjust inner content
                const title = panel.querySelector('#quick-editor-title');
                const img = panel.querySelector('#quick-editor-img');
                const body = panel.querySelector('.quick-editor-body');
                const lists = panel.querySelector('#quick-editor-lists');

                if (title) {
                    Object.assign(title.style, {
                        fontSize: '27px',
                        padding: '14px 15px 0px 15px',
                        marginTop: '7px',
                        textAlign: 'center',
                        height: '54px'
                    });
                }

                if (body) {
                    Object.assign(body.style, {
                        paddingTop: '6px'
                    });
                }

                if (lists) {
                    Object.assign(lists.style, {
                        padding: '13px',
                        flex: '1 1 0%',
                        overflowY: 'auto'
                    });
                }

                // Ensure the content is scrollable
                panel.style.paddingBottom = '50px'; // Space for controls at bottom
            },

            // Cache DOM elements
            cacheElements() {
                this.elements.modal = DOM.get('quick-editor-modal');
                this.elements.panel = DOM.get('quick-editor-content');
                this.elements.handle = DOM.get('quick-editor-title');
                this.elements.closeBtn = DOM.get('quick-editor-close');
                this.elements.mainEl = DOM.query('main');
                this.elements.spacer = DOM.get('quick-editor-spacer');
                this.elements.historySection = DOM.get('history-section');
                this.elements.notesSection = DOM.get('notes-section');
                this.elements.umSection = DOM.get('user-management-section');
                this.elements.gmSection = DOM.get('gallery-moderation-section');

                if (this.elements.panel) {
                    this.elements.originalParent = this.elements.panel.parentNode;
                }
            },

            // Utility functions
            utils: {
                vw: () => window.innerWidth,
                vh: () => window.innerHeight,
                clamp: (v, a, b) => Math.max(a, Math.min(b, v))
            },

            // Position management
            setPanelPos(left, top) {
                const { panel } = this.elements;
                if (!panel) return;

                const W = panel.offsetWidth;
                const H = panel.offsetHeight;
                const maxLeft = this.utils.vw() - W - this.config.SNAP_MARGIN;
                const maxTop = this.utils.vh() - H - this.config.SNAP_MARGIN;

                left = this.utils.clamp(Math.round(left), this.config.SNAP_MARGIN, Math.max(this.config.SNAP_MARGIN, maxLeft));
                top = this.utils.clamp(Math.round(top), this.config.SNAP_MARGIN, Math.max(this.config.SNAP_MARGIN, maxTop));

                panel.style.left = `${left}px`;
                panel.style.top = `${top}px`;
                panel.style.transform = 'none';
            },

            centerPanel() {
                const { panel } = this.elements;
                if (!panel) return;

                const w = panel.offsetWidth;
                this.setPanelPos(
                    Math.round((this.utils.vw() - w) / 2),
                    Math.round(this.utils.vh() * 0.1)
                );
            },



            // Event handlers
            onPointerDown(e) {
                if (this.state.isMobile) return;

                const { panel, mainEl } = this.elements;
                if (!panel) return;

                // Don't drag if panel is in sidebar mode
                if (panel.parentNode === mainEl) return;

                // Don't drag if clicking on interactive elements
                if (this.config.EXCLUDED_TAGS.includes(e.target.tagName)) return;

                // Only handle left mouse button
                if (e.pointerType === 'mouse' && e.button !== 0) return;

                this.state.dragging = true;
                panel.classList.add('dragging');

                try {
                    panel.setPointerCapture(e.pointerId);
                } catch (error) {
                    console.warn('Pointer capture failed:', error);
                }

                const rect = panel.getBoundingClientRect();
                this.state.startX = e.clientX;
                this.state.startY = e.clientY;
                this.state.startLeft = rect.left;
                this.state.startTop = rect.top;

                document.body.style.userSelect = 'none';
                e.preventDefault();
            },

            onPointerMove(e) {
                if (!this.state.dragging) return;

                const dx = e.clientX - this.state.startX;
                const dy = e.clientY - this.state.startY;

                this.setPanelPos(this.state.startLeft + dx, this.state.startTop + dy);
            },

            onPointerUp(e) {
                if (!this.state.dragging) return;

                const { panel } = this.elements;
                if (!panel) return;

                this.state.dragging = false;
                panel.classList.remove('dragging');

                // Smart snapping to corners
                const rect = panel.getBoundingClientRect();
                const leftDist = rect.left;
                const rightDist = this.utils.vw() - (rect.left + rect.width);
                const topDist = rect.top;
                const bottomDist = this.utils.vh() - (rect.top + rect.height);

                const finalLeft = leftDist < rightDist ?
                    this.config.SNAP_MARGIN :
                    this.utils.vw() - rect.width - this.config.SNAP_MARGIN;

                const finalTop = topDist < bottomDist ?
                    this.config.SNAP_MARGIN :
                    this.utils.vh() - rect.height - this.config.SNAP_MARGIN;

                this.setPanelPos(finalLeft, finalTop);

                document.body.style.userSelect = '';

                try {
                    panel.releasePointerCapture(e.pointerId);
                } catch (error) {
                    // Pointer capture release failed, not critical
                }
            },

            onScroll() {
                this.checkAndUpdateOverflow();
            },

            switchToSidebarMode() {
                const { panel, modal, closeBtn, spacer, mainEl } = this.elements;

                // Move panel to main content area
                if (!mainEl.contains(panel)) {
                    mainEl.insertBefore(panel, mainEl.firstChild);
                }

                // Apply sidebar styles
                Object.assign(panel.style, {
                    position: 'fixed',
                    left: `${spacer.offsetLeft}px`,
                    top: `${this.config.SIDEBAR_TOP}px`,
                    transform: 'none',
                    boxShadow: '0 6px 24px var(--shade)',
                    border: '1px solid var(--shade)',
                    background: 'linear-gradient(137deg, #4a57613d, #4a515e5e, #42546221)',
                    zIndex: 2
                });

                // Update UI elements
                closeBtn.style.display = 'none';
                spacer.style.display = 'unset';
                spacer.style.width = `${panel.offsetWidth}px`;

                // Set current mode
                this.state.currentMode = 'sidebar';

                // Check initial overflow state
                this.checkAndUpdateOverflow();

                // Start observing content changes
                this.startContentObserver();
            },

            switchToModalMode() {
                const { panel, modal, closeBtn, spacer } = this.elements;

                // Set current mode first
                this.state.currentMode = 'modal';

                // Stop observing content changes in modal mode
                this.stopContentObserver();

                // Move panel back to modal
                if (!modal.contains(panel)) {
                    modal.appendChild(panel);
                }

                // Apply modal styles
                Object.assign(panel.style, {
                    position: 'fixed',
                    boxShadow: '0 10px 30px rgba(0, 0, 0, 0.45)',
                    border: '',
                    background: ''
                });

                // Update UI elements
                closeBtn.style.display = 'unset';
                spacer.style.display = 'none';
                spacer.style.height = '0px'; // Reset spacer height

                // Keep panel within viewport bounds
                const rect = panel.getBoundingClientRect();
                const finalLeft = this.utils.clamp(
                    rect.left,
                    this.config.SNAP_MARGIN,
                    Math.max(this.config.SNAP_MARGIN, this.utils.vw() - rect.width - this.config.SNAP_MARGIN)
                );
                const finalTop = this.utils.clamp(
                    rect.top,
                    this.config.SNAP_MARGIN,
                    Math.max(this.config.SNAP_MARGIN, this.utils.vh() - rect.height - this.config.SNAP_MARGIN)
                );

                this.setPanelPos(finalLeft, finalTop);
            },

            // Event listener setup
            setupEventListeners() {
                const { panel, closeBtn, modal } = this.elements;

                if (panel) {
                    panel.addEventListener('pointerdown', (e) => this.onPointerDown(e));
                }

                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        modal?.classList.add('hidden');
                    });
                }

                // Global pointer events
                window.addEventListener('pointermove', (e) => this.onPointerMove(e));
                window.addEventListener('pointerup', (e) => this.onPointerUp(e));

                // ADD THIS: Scroll event listener for continuous checking
                window.addEventListener('scroll', () => {
                    if (this.state.currentMode === 'sidebar') {
                        this.checkAndUpdateOverflow();
                    }
                });

                // Debounced resize handler
                const debouncedResize = Utils.debounce(() => this.handleResize(), 150);
                window.addEventListener('resize', debouncedResize);

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && !modal?.classList.contains('hidden')) {
                        modal.classList.add('hidden');
                    }
                });
            },

            // Updated checkAndUpdateOverflow method
            checkAndUpdateOverflow() {
                const { panel, spacer } = this.elements;
                if (!panel || !spacer || this.state.currentMode !== 'sidebar') return;

                const panelHeight = panel.offsetHeight;
                const sidebarTop = this.config.SIDEBAR_TOP;
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

                // Get panel's horizontal boundaries from spacer
                const spacerRect = spacer.getBoundingClientRect();
                const panelLeft = spacerRect.left;
                const panelRight = spacerRect.right;

                // Get all sections that could be below
                const sections = [
                    this.elements.historySection,
                    this.elements.notesSection,
                    this.elements.umSection,
                    this.elements.gmSection
                ].filter(Boolean);

                // Find the section that's actually below the panel (horizontally overlapping)
                let targetSection = null;
                let minDistance = Infinity;

                for (const section of sections) {
                    const sectionRect = section.getBoundingClientRect();
                    const sectionLeft = sectionRect.left;
                    const sectionRight = sectionRect.right;

                    // Check if section overlaps horizontally with panel
                    const overlaps = !(sectionRight < panelLeft || sectionLeft > panelRight);

                    if (overlaps) {
                        const sectionTopAbs = scrollTop + sectionRect.top;

                        // Find the closest section below the spacer
                        if (sectionTopAbs < minDistance) {
                            minDistance = sectionTopAbs;
                            targetSection = section;
                        }
                    }
                }

                if (targetSection) {
                    const targetRect = targetSection.getBoundingClientRect();
                    const sectionTopAbs = scrollTop + targetRect.top;
                    const gap = 40;

                    // Define gutter boundaries (absolute positions in document)
                    const gutterTop = spacerRect.top + scrollTop; // Where spacer starts in document
                    const gutterBottom = sectionTopAbs - gap; // Where section starts minus gap

                    // Where panel would be if fixed at viewport top
                    const desiredTop = scrollTop + sidebarTop;
                    const desiredBottom = desiredTop + panelHeight;

                    // Check if panel fits in gutter at desired position
                    if (desiredBottom <= gutterBottom) {
                        // Panel fits - use fixed positioning (follows scroll)
                        panel.style.position = 'fixed';
                        panel.style.top = `${sidebarTop}px`;
                        spacer.style.height = '0px';
                        delete panel.dataset.scrollMode;
                    } else {
                        // Panel would overflow gutter - pin to bottom of gutter
                        panel.style.position = 'absolute';
                        panel.style.top = `${gutterBottom - panelHeight}px`;
                        spacer.style.height = `${panelHeight}px`;
                        panel.dataset.scrollMode = 'stuck';
                    }
                } else {
                    // No section below, stay fixed
                    panel.style.position = 'fixed';
                    panel.style.top = `${sidebarTop}px`;
                    spacer.style.height = '0px';
                    delete panel.dataset.scrollMode;
                }

                // Update horizontal position and constraints
                panel.style.left = `${spacerRect.left}px`;
                panel.style.maxHeight = `calc(100vh - ${sidebarTop + 20}px)`;
                panel.style.overflowY = 'auto';
            },


            // Observer for modal visibility changes
            setupObserver() {
                const { modal } = this.elements;
                if (!modal) return;

                this.state.observer = new MutationObserver(() => {
                    if (!modal.classList.contains('hidden')) {
                        requestAnimationFrame(() => this.handleResize());
                    }
                });

                this.state.observer.observe(modal, {
                    attributes: true,
                    attributeFilter: ['class']
                });
            },

            // Public API methods
            show() {
                const { modal } = this.elements;
                if (modal) {
                    modal.classList.remove('hidden');
                    modal.classList.add('show');
                }
            },

            hide() {
                const { modal } = this.elements;
                if (modal) {
                    modal.classList.add('hidden');
                    modal.classList.remove('show');
                }
            },

            isVisible() {
                const { modal } = this.elements;
                return modal && !modal.classList.contains('hidden');
            },

            // Start observing content changes for dynamic overflow
            startContentObserver() {
                if (this.state.contentObserver) return; // Already observing

                const { panel } = this.elements;
                if (!panel) return;

                // Use ResizeObserver to detect when panel content changes size
                this.state.contentObserver = new ResizeObserver(() => {
                    // Debounce the overflow check to avoid excessive calls
                    clearTimeout(this.overflowCheckTimeout);
                    this.overflowCheckTimeout = setTimeout(() => {
                        this.checkAndUpdateOverflow();
                    }, 100);
                });

                this.state.contentObserver.observe(panel);

                // Also observe for DOM mutations (adding/removing elements)
                this.state.mutationObserver = new MutationObserver(() => {
                    clearTimeout(this.overflowCheckTimeout);
                    this.overflowCheckTimeout = setTimeout(() => {
                        this.checkAndUpdateOverflow();
                    }, 100);
                });

                this.state.mutationObserver.observe(panel, {
                    childList: true,
                    subtree: true,
                    attributes: false
                });
            },

            // Stop observing content changes
            stopContentObserver() {
                if (this.state.contentObserver) {
                    this.state.contentObserver.disconnect();
                    this.state.contentObserver = null;
                }

                if (this.state.mutationObserver) {
                    this.state.mutationObserver.disconnect();
                    this.state.mutationObserver = null;
                }

                if (this.overflowCheckTimeout) {
                    clearTimeout(this.overflowCheckTimeout);
                    this.overflowCheckTimeout = null;
                }
            },

            // Enhanced handleResize with mode tracking
            handleResize() {
                const { panel, modal, closeBtn, spacer, mainEl } = this.elements;
                if (!panel || !modal || !spacer || !mainEl) return;

                // Check if mobile
                this.checkMobile();

                if (this.state.isMobile) {
                    this.switchToMobileMode();
                } else {
                    const isWideScreen = this.utils.vw() > this.config.WIDTH_THRESHOLD;

                    if (isWideScreen) {
                        this.switchToSidebarMode();
                    } else {
                        this.switchToModalMode();
                    }
                }
            },

            // Enhanced cleanup
            destroy() {
                this.stopContentObserver();

                if (this.state.observer) {
                    this.state.observer.disconnect();
                    this.state.observer = null;
                }

                this.state.isInitialized = false;
                this.state.currentMode = null;
            },

            // Public method to manually trigger overflow check (useful for external calls)
            refreshOverflow() {
                if (this.state.currentMode === 'sidebar') {
                    this.checkAndUpdateOverflow();
                }
            }

        };

        // ============================
        // Gallery Moderation
        // ============================
        const GalleryMod = {
            async init() {
                await this.loadPendingItems();
                // Refresh every 30 seconds
                setInterval(() => this.loadPendingItems(), 30000);
            },

            async loadPendingItems() {
                const container = document.getElementById('pending-gallery-items');
                if (!container) return;

                try {
                    const response = await fetch('https://emwiki.com/api/gallery/pending', {
                        headers: {
                            'Authorization': `Bearer ${Auth.session}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Failed to load pending items');
                    }

                    const { items } = await response.json();

                    if (items.length === 0) {
                        container.innerHTML = '<p class="loading">No pending submissions</p>';
                        return;
                    }

                    container.innerHTML = '';
                    items.forEach(item => {
                        container.appendChild(this.createPendingItem(item));
                    });
                } catch (error) {
                    console.error('Failed to load pending items:', error);
                    container.innerHTML = '<p class="error">Failed to load pending submissions</p>';
                }
            },

            createProfilePill(username, avatarUrl, role) {
                let roles = ['user'];
                if (role) {
                    try {
                        roles = JSON.parse(role);
                    } catch (e) {
                        // If role is already an array or invalid JSON, handle gracefully
                        roles = Array.isArray(role) ? role : [role];
                    }
                }
                const highestRole = this.getHighestRole(roles);
                const roleLabel = highestRole !== 'user' ? `<span class="profile-pill-role role-${highestRole}">${highestRole}</span>` : '';
                const avatar = avatarUrl || 'https://via.placeholder.com/48';

                return `
                    <div class="profile-pill">
                        <img class="profile-pill-avatar" src="${avatar}" alt="${this.escapeHtml(username)}" onerror="this.src='https://via.placeholder.com/48'">
                        <span class="profile-pill-name">${this.escapeHtml(username)}</span>
                        ${roleLabel}
                    </div>
                `;
            },

            getHighestRole(roles) {
                // Priority: admin > moderator/mod > vip > user
                if (roles.includes('admin')) return 'admin';
                if (roles.includes('moderator')) return 'moderator';
                if (roles.includes('mod')) return 'mod';
                if (roles.includes('vip')) return 'vip';
                return 'user';
            },

            createPendingItem(item) {
                const div = document.createElement('div');
                div.className = 'gallery-pending-item';
                div.style.cssText = `
                    display: flex;
                    gap: 15px;
                    padding: 15px;
                    margin-bottom: 15px;
                    background: var(--bg-item);
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                `;

                const mediaElement = item.media_type === 'video'
                    ? `<div style="position: relative; width: 200px; height: 153px; background: #000; border-radius: 6px; overflow: hidden;">
                           <video src="${item.media_url}" controls preload="metadata" style="width: 100%; height: 100%; object-fit: cover;"></video>
                           <div style="position: absolute; top: 8px; right: 8px; width: 28px; height: 28px; background: rgba(0,0,0,0.75); border-radius: 6px; display: flex; align-items: center; justify-content: center; pointer-events: none; backdrop-filter: blur(4px);">
                               <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: white;" xmlns="http://www.w3.org/2000/svg">
                                   <path d="M8 5v14l11-7z"/>
                               </svg>
                           </div>
                       </div>`
                    : `<img src="${item.media_url}" alt="${item.title}" style="width: 200px; height: 153px; object-fit: cover; border-radius: 6px; background: #000;">`;

                const profilePill = this.createProfilePill(item.username, item.avatar_url, item.role);

                div.innerHTML = `
                    ${mediaElement}
                    <div style="flex: 1;">
                        <div style="font-weight: 600; font-size: 1.1rem; margin-bottom: 5px;">${this.escapeHtml(item.title)}</div>
                        <div style="margin-bottom: 5px;">${profilePill}</div>
                        <div style="margin-bottom: 5px;">${this.escapeHtml(item.description || 'No description')}</div>
                        <div style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 5px;">
                            Submitted ${this.formatDate(item.created_at)}
                        </div>
                        <div style="flex-wrap: wrap;display: flex; gap: 8px;">
                            <button class="approve-btn" data-id="${item.id}" style="
                                padding: 8px 16px;
                                background: rgba(76, 175, 80, 0.2);
                                color: #4caf50;
                                border: 1px solid rgba(76, 175, 80, 0.4);
                                border-radius: 4px;
                                cursor: pointer;
                                font-weight: 600;
                            ">Approve</button>
                            <button class="reject-btn" data-id="${item.id}" style="
                                padding: 8px 16px;
                                background: rgba(244, 67, 54, 0.2);
                                color: #f44336;
                                border: 1px solid rgba(244, 67, 54, 0.4);
                                border-radius: 4px;
                                cursor: pointer;
                                font-weight: 600;
                            ">Reject</button>
                        </div>
                    </div>
                `;

                // Event listeners
                const approveBtn = div.querySelector('.approve-btn');
                const rejectBtn = div.querySelector('.reject-btn');

                approveBtn.addEventListener('click', () => this.moderateItem(item.id, 'approve'));
                rejectBtn.addEventListener('click', () => this.moderateItem(item.id, 'reject'));

                return div;
            },

            async moderateItem(id, action) {
                let reason = null;

                if (action === 'reject') {
                    reason = prompt('Enter rejection reason (optional):');
                    if (reason === null) return; // User cancelled
                }

                try {
                    const response = await fetch(`/api/gallery/moderate/${id}`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${Auth.session}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ action, reason })
                    });

                    if (!response.ok) {
                        throw new Error('Moderation failed');
                    }

                    const result = await response.json();
                    console.log(result.message);

                    // Reload pending items
                    await this.loadPendingItems();
                } catch (error) {
                    console.error('Moderation error:', error);
                    alert('Failed to moderate item: ' + error.message);
                }
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            formatDate(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();
                const diff = now - date;

                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);

                if (minutes < 60) {
                    return `${minutes}m ago`;
                } else if (hours < 24) {
                    return `${hours}h ago`;
                } else if (days < 7) {
                    return `${days}d ago`;
                } else {
                    return date.toLocaleDateString();
                }
            }
        };

        // ============================
        // User Management
        // ============================
        const UserManagement = {
            async init() {
                const searchBtn = document.getElementById('user-search-btn');
                const searchInput = document.getElementById('user-search-input');

                if (searchBtn) {
                    searchBtn.addEventListener('click', () => this.searchUser());
                }

                if (searchInput) {
                    searchInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') this.searchUser();
                    });
                }
            },

            async searchUser() {
                const searchInput = document.getElementById('user-search-input');
                const resultsContainer = document.getElementById('user-management-results');
                const query = searchInput.value.trim();

                if (!query) {
                    resultsContainer.innerHTML = '<p class="error">Please enter a username or user ID</p>';
                    return;
                }

                resultsContainer.innerHTML = '<p class="loading">Searching...</p>';

                try {
                    // Search in local database first
                    const response = await fetch(`https://emwiki.com/api/auth/user/search?q=${encodeURIComponent(query)}`, {
                        headers: {
                            'Authorization': `Bearer ${Auth.session}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Search failed');
                    }

                    const { users } = await response.json();

                    if (users.length === 0) {
                        resultsContainer.innerHTML = '<p class="loading">No users found in database</p>';
                        return;
                    }

                    resultsContainer.innerHTML = '';
                    users.forEach(user => {
                        resultsContainer.appendChild(this.createUserCard(user));
                    });
                } catch (error) {
                    console.error('Search error:', error);
                    resultsContainer.innerHTML = '<p class="error">Failed to search users</p>';
                }
            },

            createUserCard(user) {
                const div = document.createElement('div');
                div.style.cssText = `
                    padding: 20px;
                    background: #6363631c;
                    border: 1px solid #6363637d;
                    border-radius: 12px;
                    margin-bottom: 15px;
                `;

                const roles = JSON.parse(user.role || '["user"]');
                const rolesHtml = roles.map(role => {
                    const colors = {
                        'admin': '#f44336',
                        'moderator': '#ff9800',
                        'vip': '#9c27b0',
                        'donator': '#4caf50',
                        'user': '#666'
                    };
                    return `<span style="
                        display: inline-block;
                        padding: 4px 10px;
                        background: ${colors[role] || '#666'}22;
                        color: ${colors[role] || '#666'};
                        border-radius: 4px;
                        font-size: 0.85rem;
                        font-weight: 600;
                        margin-right: 5px;
                        margin-bottom: 5px;
                    ">${role}</span>`;
                }).join('');

                div.innerHTML = `
                    <div style="display: flex; gap: 15px; align-items: start; margin-bottom: 15px;">
                        <img src="${user.avatar_url || '/imgs/default-avatar.png'}" alt="${user.username}"
                            style="width: 80px; height: 80px; border-radius: 50%; border: 2px solid var(--border-color);">
                        <div style="flex: 1;">
                            <div style="font-size: 1.3rem; font-weight: 600; margin-bottom: 5px;">
                                ${this.escapeHtml(user.display_name || user.username)}
                            </div>
                            <div style="color: var(--text-secondary); margin-bottom: 10px;">
                                @${this.escapeHtml(user.username)}
                            </div>
                            <div style="margin-bottom: 10px;">
                                ${rolesHtml}
                            </div>
                        </div>
                    </div>

                    <div style="border-top: 1px solid var(--border-color); padding-top: 15px;">
                        <div style="font-weight: 600; margin-bottom: 10px;">Manage Roles</div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                            ${this.createRoleButton('admin', roles, user.user_id)}
                            ${this.createRoleButton('moderator', roles, user.user_id)}
                            ${this.createRoleButton('vip', roles, user.user_id)}
                            ${this.createRoleButton('donator', roles, user.user_id)}
                        </div>
                    </div>
                `;

                // Add event listeners for role buttons
                div.querySelectorAll('.role-toggle-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const role = btn.dataset.role;
                        const userId = btn.dataset.userId;
                        const action = btn.dataset.action;
                        this.toggleRole(userId, role, action, div);
                    });
                });

                return div;
            },

            createRoleButton(role, currentRoles, userId) {
                const hasRole = currentRoles.includes(role);
                const action = hasRole ? 'remove' : 'add';
                const colors = {
                    'admin': '#f44336',
                    'moderator': '#ff9800',
                    'vip': '#9c27b0',
                    'donator': '#4caf50'
                };

                return `
                    <button class="role-toggle-btn" data-role="${role}" data-user-id="${userId}" data-action="${action}"
                        style="
                            padding: 10px 15px;
                            background: ${hasRole ? colors[role] + '33' : 'transparent'};
                            color: ${colors[role]};
                            border: 2px solid ${colors[role]};
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: 600;
                            transition: all 0.2s ease;
                            text-transform: capitalize;
                        ">
                        ${hasRole ? 'âœ“' : '+'} ${role}
                    </button>
                `;
            },

            async toggleRole(userId, role, action, cardElement) {
                if (!confirm(`Are you sure you want to ${action} the "${role}" role ${action === 'add' ? 'to' : 'from'} this user?`)) {
                    return;
                }

                try {
                    const response = await fetch('/api/auth/admin/update-role', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${Auth.session}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            userId: userId,
                            role: role,
                            action: action
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update role');
                    }

                    // Refresh the user card
                    const searchInput = document.getElementById('user-search-input');
                    await this.searchUser();

                    // Show success message
                    ErrorHandler.showToast(`Successfully ${action}ed ${role} role`, 'success');
                } catch (error) {
                    console.error('Role toggle error:', error);
                    ErrorHandler.showToast('Failed to update role: ' + error.message, 'error');
                }
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        };

        // ============================
        // Initialize on DOM ready
        // ============================
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                Auth.init();
                initializeDemandReview();
            });
        } else {
            Auth.init();
            initializeDemandReview();
        }

        // Initialize Demand Review when section becomes visible
        function initializeDemandReview() {
            const reviewSection = document.getElementById('demand-review-section');
            if (reviewSection) {
                const observer = new MutationObserver((mutations) => {
                    if (reviewSection.style.display !== 'none' && DemandReview.reviewItems.length === 0) {
                        DemandReview.init();
                    }
                });
                observer.observe(reviewSection, { attributes: true, attributeFilter: ['style'] });

                // Also try to init immediately if visible
                setTimeout(() => {
                    if (reviewSection.style.display !== 'none') {
                        DemandReview.init();
                    }
                }, 2000);
            }
        }

        // Get the accent color from root
        const root = document.documentElement;
        const rootStyles = getComputedStyle(root);
        const accentColor = rootStyles.getPropertyValue('--accent').trim();

        // Add transparency (66 in hex = 40% opacity)
        const accentTransparent = accentColor + '66';

        // Set the new transparent variable on root
        //root.style.setProperty('--accent-transparent', accentTransparent);

        // Add CSS for icons
        const style = document.createElement('style');
        style.textContent = `
        .icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-color: currentColor;
            mask-size: contain;
            mask-repeat: no-repeat;
            mask-position: center;
        }
        .download-icon { mask-image: url('${CONFIG.ICONS.download}'); }
        .logout-icon { mask-image: url('${CONFIG.ICONS.logout}'); }
        .send-icon { mask-image: url('${CONFIG.ICONS.send}');rotate: 47deg;}
        .edit-icon { mask-image: url('${CONFIG.ICONS.edit}'); }
        .delete-icon { mask-image: url('${CONFIG.ICONS.delete}'); }
        .check-icon { mask-image: url('${CONFIG.ICONS.check}'); }
        .gamenight-icon { mask-image: url('${CONFIG.ICONS.gamenight}'); }
        .prices-icon { mask-image: url('${CONFIG.ICONS.prices}'); }
        .newest-icon { mask-image: url('${CONFIG.ICONS.newest}'); }

        .loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }

        .error {
            text-align: center;
            padding: 20px;
            color: #f66;
        }

        /* Demand Rating Buttons */
        .demand-rating-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid #6363637d;
            background: #63636347;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 400;
            transition: all 0.2s;
            font-size: 14px;
        }

        .demand-rating-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .demand-rating-section {
            background: #00000030;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #ffffff0d;
        }

    `;
        document.head.appendChild(style);
        // ============================
        // DEMAND REVIEW SYSTEM
        // ============================
        const DemandReview = {
            reviewItems: [],
            currentItems: [],
            currentPage: 1,
            itemsPerPage: 20,
            searchQuery: '',
            categoryFilter: 'all',
            showNoRating: true,
            showOldRating: true,

            async init() {
                await this.loadDemandData();
                this.setupEventListeners();
                this.renderItems();
            },

            async loadDemandData() {
                try {
                    // Get demand ratings from database
                    const response = await fetch('https://emwiki.com/api/demand/all');
                    const data = await response.json();

                    const demandMap = new Map();
                    const now = Date.now();
                    const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);

                    if (data.demand && Array.isArray(data.demand)) {
                        data.demand.forEach(d => {
                            const key = `${d.category}-${d.item_name}`;
                            const updatedAt = d.updated_at ? new Date(d.updated_at).getTime() : 0;
                            demandMap.set(key, {
                                demand: d.demand,
                                updatedAt: updatedAt,
                                isOld: updatedAt < thirtyDaysAgo
                            });
                        });
                    }

                    // Check all items in state and find ones needing review
                    this.reviewItems = [];

                    Object.entries(state.jsData).forEach(([category, items]) => {
                        if (Array.isArray(items)) {
                            items.forEach(item => {
                                const key = `${category}-${item.name}`;
                                const demandData = demandMap.get(key);

                                const needsReview = !demandData || demandData.demand === 0 || demandData.isOld;

                                if (needsReview) {
                                    this.reviewItems.push({
                                        name: item.name,
                                        category: category,
                                        demand: demandData?.demand || 0,
                                        updatedAt: demandData?.updatedAt || 0,
                                        isOld: demandData?.isOld || false,
                                        hasNoRating: !demandData || demandData.demand === 0
                                    });
                                }
                            });
                        }
                    });

                    console.log(`Found ${this.reviewItems.length} items needing demand review`);
                } catch (error) {
                    console.error('Failed to load demand data:', error);
                }
            },

            setupEventListeners() {
                const searchInput = document.getElementById('demand-search-input');
                const categoryFilter = document.getElementById('demand-category-filter');
                const prevBtn = document.getElementById('demand-prev-btn');
                const nextBtn = document.getElementById('demand-next-btn');
                const showNoRating = document.getElementById('show-no-rating');
                const showOldRating = document.getElementById('show-old-rating');

                searchInput?.addEventListener('input', (e) => {
                    this.searchQuery = e.target.value.toLowerCase();
                    this.currentPage = 1;
                    this.renderItems();
                });

                categoryFilter?.addEventListener('change', (e) => {
                    this.categoryFilter = e.target.value;
                    this.currentPage = 1;
                    this.renderItems();
                });

                showNoRating?.addEventListener('change', (e) => {
                    this.showNoRating = e.target.checked;
                    this.currentPage = 1;
                    this.renderItems();
                });

                showOldRating?.addEventListener('change', (e) => {
                    this.showOldRating = e.target.checked;
                    this.currentPage = 1;
                    this.renderItems();
                });

                prevBtn?.addEventListener('click', () => {
                    if (this.currentPage > 1) {
                        this.currentPage--;
                        this.renderItems();
                    }
                });

                nextBtn?.addEventListener('click', () => {
                    const maxPage = Math.ceil(this.currentItems.length / this.itemsPerPage);
                    if (this.currentPage < maxPage) {
                        this.currentPage++;
                        this.renderItems();
                    }
                });
            },

            renderItems() {
                // Filter items
                this.currentItems = this.reviewItems.filter(item => {
                    const matchesSearch = !this.searchQuery ||
                        item.name.toLowerCase().includes(this.searchQuery);
                    const matchesCategory = this.categoryFilter === 'all' ||
                        item.category === this.categoryFilter;
                    const matchesFilter = (this.showNoRating && item.hasNoRating) ||
                        (this.showOldRating && item.isOld);

                    return matchesSearch && matchesCategory && matchesFilter;
                });

                // Paginate
                const start = (this.currentPage - 1) * this.itemsPerPage;
                const end = start + this.itemsPerPage;
                const pageItems = this.currentItems.slice(start, end);

                // Render grid
                const grid = document.getElementById('demand-items-grid');
                if (!grid) return;

                    grid.innerHTML = pageItems.map(item => this.renderItemCard(item)).join('');


                // Update pagination
                this.updatePagination();

                // Add double-click handlers to open Quick Editor
                pageItems.forEach(item => {
                    const card = document.getElementById(`review-card-${item.category}-${item.name}`);
                    if (card) {
                        card.addEventListener('dblclick', () => {
                            const actualItem = this.findItemInState(item.name, item.category);
                            if (actualItem) {
                                QuickEditor.open(actualItem);
                            }
                        });
                        card.style.cursor = 'pointer';
                    }
                });
            },

            findItemInState(name, category) {
                const categoryItems = state.jsData[category];
                if (!categoryItems) return null;
                return categoryItems.find(item => item.name === name);
            },

            renderItemCard(item) {
                const demandLabels = {
                    5: 'Amazing',
                    4: 'Great',
                    3: 'Good',
                    2: 'Okay',
                    1: 'Bad',
                    0: 'Not Set'
                };

                const demandColors = {
                    5: '#90EE90',
                    4: '#ADD8E6',
                    3: '#FFD700',
                    2: '#FFA500',
                    1: '#FF6347',
                    0: '#CD5C5C'
                };

                const statusBadge = item.hasNoRating
                    ? '<span style="background: #ef444433; border: 1px solid #ef4444; color: #ef4444; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">NO RATING</span>'
                    : item.isOld
                    ? '<span style="background: #ff980033; border: 1px solid #ff9800; color: #ff9800; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">OLD (30+ days)</span>'
                    : '';

                const lastUpdated = item.updatedAt
                    ? new Date(item.updatedAt).toLocaleDateString()
                    : 'Never';

                return `
                    <div id="review-card-${item.category}-${item.name}" style="
                        background: #2a2a2a;
                        padding: 12px;
                        border-radius: 8px;
                        border: 1px solid #6363637d;
                        transition: all 0.2s;
                    "
                    onmouseover="this.style.borderColor='#3b82f6'; this.style.transform='translateY(-2px)'"
                    onmouseout="this.style.borderColor='#6363637d'; this.style.transform='translateY(0)'"
                    title="Double-click to edit in Quick Editor">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: white; margin-bottom: 4px;">${item.name}</div>
                                <div style="font-size: 11px; color: var(--text-secondary); text-transform: capitalize; margin-bottom: 4px;">${item.category}</div>
                                ${statusBadge}
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; padding-top: 8px; border-top: 1px solid #6363637d;">
                            <div>
                                <div style="font-size: 11px; color: var(--text-secondary);">Current: <strong style="color: ${demandColors[item.demand]};">${demandLabels[item.demand]}</strong></div>
                                <div style="font-size: 10px; color: var(--text-secondary); margin-top: 2px;">Updated: ${lastUpdated}</div>
                            </div>
                            <div style="font-size: 11px; color: #3b82f6; font-style: italic;">Double-click to edit</div>
                        </div>
                    </div>
                `;
            },

            updatePagination() {
                const maxPage = Math.ceil(this.currentItems.length / this.itemsPerPage);
                const pageInfo = document.getElementById('demand-page-info');
                const prevBtn = document.getElementById('demand-prev-btn');
                const nextBtn = document.getElementById('demand-next-btn');

                if (pageInfo) {
                    pageInfo.textContent = `Page ${this.currentPage} of ${maxPage || 1} (${this.currentItems.length} items need review)`;
                }

                if (prevBtn) {
                    prevBtn.disabled = this.currentPage <= 1;
                }

                if (nextBtn) {
                    nextBtn.disabled = this.currentPage >= maxPage;
                }
            }
        };

    </script>
</body>

</html>