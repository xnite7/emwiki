<!DOCTYPE html>
<html lang="en">

<head>

    <link href="https://fonts.cdnfonts.com/css/zekton" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/highway-gothic" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/comic-neue-angular" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/roman-antique" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/accanthis-adf-std" rel="stylesheet">

    <!-- Add JSZip library for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Title SVG System</title>
    <style>
        @import url("https://emwiki.site/css/fonts.css");
    </style>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            padding: 20px;
        }

        .title-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .title-card {
            background: #2a2a2a;
            border-radius: 8px;

            text-align: center;
            border: 1px solid #3a3a3a;
        }

        .title-svg {
            width: 100%;
            height: 60px;
            margin-bottom: 10px;
        }

        .title-info {
            font-size: 12px;
            color: #888;
        }

        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #45a049;
        }

        button.secondary {
            background: #2196F3;
        }

        button.secondary:hover {
            background: #1976D2;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        textarea {
            width: 100%;
            height: 200px;
            background: #1a1a1a;
            color: #0f0;
            border: 1px solid #3a3a3a;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            margin-top: 10px;
        }

        .progress {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background: #333;
            border-radius: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #555;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }

        .progress-text {
            margin-top: 5px;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <h1>Title SVG Conversion System</h1>

    <div class="controls">
        <button onclick="generateAllSVGs()">Generate All SVGs</button>
        <button onclick="exportData()">Export Updated Data</button>
        <button onclick="showSample()">Show Sample Titles</button>
        <button class="secondary" onclick="downloadAllAsPNGs()">Download All as PNGs (ZIP)</button>
        <div id="status"></div>
        <div id="progress" class="progress">
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%"></div>
            </div>
            <div id="progressText" class="progress-text">Processing...</div>
        </div>
        <textarea id="output" placeholder="Generated data will appear here..."></textarea>
    </div>

    <div id="titleGrid" class="title-grid"></div>

    <script>
        // Title SVG Generator Class
        class TitleSVGGenerator {
            constructor() {
                this.defaultFont = '600 28px Arimo';
                this.defaultColor = '#ffffff';
            }

            generateSVG(title) {
                const width = 200;
                const height = 100;

                // Parse style properties
                const styles = this.parseStyles(title);

                // Create SVG with foreignObject for complex text rendering
                const stroke = styles.stroke

                //split stroke into size and color
                let [strokeSize, strokeColor] = [null, null];
                if (stroke) {
                    [strokeSize, strokeColor] = stroke.split(' ');
                } else {
                    strokeSize = null;
                    strokeColor = null;
                }

                // Create a temporary SVG to measure text bounds
                const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                tempSvg.setAttribute('width', '1000');
                tempSvg.setAttribute('height', '1000');
                tempSvg.style.position = 'absolute';
                tempSvg.style.visibility = 'hidden';
                document.body.appendChild(tempSvg);

                // Create text element
                const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textElement.setAttribute('x', '500');
                textElement.setAttribute('y', '500');
                textElement.setAttribute('text-anchor', 'middle');
                textElement.setAttribute('fill', styles.color);

                // Apply stroke if present
                if (strokeSize && strokeColor) {
                    textElement.setAttribute('stroke', strokeColor);
                    textElement.setAttribute('stroke-width', strokeSize.slice(0, -2) * 2);
                    textElement.setAttribute('paint-order', 'stroke');
                }

                // Apply styles
                textElement.setAttribute('style', this.generateDivStyle(styles, title));
                textElement.textContent = this.generateTextContent(title, styles);

                tempSvg.appendChild(textElement);

                // Get bounding box
                let bbox;
                try {
                    bbox = textElement.getBBox();
                } catch (e) {
                    // Fallback if getBBox fails
                    bbox = { x: 450, y: 480, width: 100, height: 40 };
                }

                // Calculate padding based on stroke width
                const strokePadding = strokeSize ? parseFloat(strokeSize) * 2 : 2;
                const padding = Math.max(strokePadding, 4);

                // Calculate viewBox with padding
                const viewBoxX = bbox.x - padding;
                const viewBoxY = bbox.y - padding;
                const viewBoxWidth = bbox.width + (padding * 2);
                const viewBoxHeight = bbox.height + (padding * 2);

                // Remove temporary SVG
                document.body.removeChild(tempSvg);

                // Create final SVG with adjusted viewBox
                const svg = `
                <svg width="${width}" height="${height}" viewBox="${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
                    
                    <text x="500" y="500" xmlns="http://www.w3.org/2000/svg" text-anchor="middle" ${this.generateTextStroke2(strokeSize, strokeColor)} fill="${styles.color}" style="${this.generateDivStyle(styles, title)}">
                        ${this.generateTextContent(title, styles)}
                    </text>
                </svg>`;

                return svg;
            }

            parseStyles(title) {
                const styles = {
                    font: title.font || this.defaultFont,
                    color: title.color || this.defaultColor,
                    stroke: title.stroke || null,
                    style: title.style || null,
                    style2: title.style2 || null,
                    style3: title.style3 || null,
                    rotate: title.rotate || null
                };

                return styles;
            }

            generateDivStyle(styles, title) {
                let divStyle = `
                    font: ${styles.font};
                    color: ${styles.color};
                `;



                // Add rotation
                if (styles.rotate) {
                    divStyle += `transform: rotate(${styles.rotate}deg);`;
                }

                // Parse and add style2 properties
                if (styles.style2) {
                    const style2Props = this.parseInlineStyle(styles.style2);
                    divStyle += style2Props;
                }

                // Parse and add style properties
                if (styles.style) {
                    const styleProps = this.parseInlineStyle(styles.style);
                    divStyle += styleProps;
                }

                return divStyle;
            }

            generateTextContent(title, styles) {
                // Handle special HTML content in style3
                if (styles.style3) {
                    // Extract the content from style3 HTML
                    const match = styles.style3.match(/>([^<]+)</);
                    if (match) {
                        return match[1];
                    }
                }

                return title.name;
            }

            generateTextStroke(size, color) {
                const positions = [
                    [-1, -1], [0, -1], [1, -1],
                    [-1, 0], [1, 0],
                    [-1, 1], [0, 1], [1, 1]
                ];

                return positions
                    .map(([x, y]) => {
                        const xSize = x === 0 ? '0' : `${x * parseFloat(size)}px`;
                        const ySize = y === 0 ? '0' : `${y * parseFloat(size)}px`;
                        return `${xSize} ${ySize} 0 ${color}`;
                    })
                    .join(', ');
            }

            generateTextStroke2(size, color) {
                if (!size || !color) return '';
                console.log(size.slice(0, -2) * 2);
                return `stroke="${color}" stroke-width="${size.slice(0, -2) * 2}" paint-order="stroke"`;
            }

            generateGradientDefs(styles) {
                if (!styles.style2 || !styles.style2.includes('gradient')) {
                    return '';
                }

                // Extract gradient from style2
                const gradientMatch = styles.style2.match(/linear-gradient\(([^)]+)\)/);
                if (!gradientMatch) return '';

                return `
                    <linearGradient id="textGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#ff0000;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#00ff00;stop-opacity:1" />
                    </linearGradient>
                `;
            }

            generateFilterDefs(styles) {
                // Add glow or other filter effects if needed
                if (styles.style && styles.style.includes('text-shadow')) {
                    return `
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    `;
                }
                return '';
            }

            parseInlineStyle(styleString) {
                // Clean up the style string and extract relevant CSS properties
                const cleaned = styleString
                    .replace(/bottom:\s*0px;?/gi, '')
                    .replace(/white-space:\s*nowrap;?/gi, '')
                    .replace(/font:\s*[^;]+;?/gi, '') // Remove font as we handle it separately
                    .trim();

                return cleaned;
            }

            svgToDataURL(svg) {
                const encoded = encodeURIComponent(svg)
                    .replace(/'/g, '%27')
                    .replace(/"/g, '%22');
                return `data:image/svg+xml,${encoded}`;
            }
        }

        // Sample titles data
        const sampleTitles = []
        let generator = new TitleSVGGenerator();
        let allTitles = [];

        function generateAllSVGs() {
            const status = document.getElementById('status');
            status.textContent = 'Generating SVGs...';

            // Process sample titles
            const processedTitles = sampleTitles.map(title => {
                if (!title.img) {
                    // Generate SVG for titles without existing images
                    const svgDataURL = generator.generateSVG(title);
                    return {
                        ...title,
                        img: svgDataURL,
                        // Remove old style properties
                        font: undefined,
                        color: undefined,
                        stroke: undefined,
                        style: undefined,
                        style2: undefined,
                        style3: undefined,
                        rotate: undefined
                    };
                }
                return title;
            });

            allTitles = processedTitles;
            status.textContent = `Generated ${processedTitles.length} SVGs successfully!`;

            // Display the titles
            displayTitles(processedTitles);
        }

        function displayTitles(titles) {
            const grid = document.getElementById('titleGrid');
            grid.innerHTML = '';

            titles.forEach(title => {
                const card = document.createElement('div');
                card.className = 'title-card';

                card.innerHTML = title.img;

                const info = document.createElement('div');
                info.className = 'title-info';
                info.textContent = title.name;


                card.appendChild(info);
                grid.appendChild(card);
            });
        }

        function exportData() {
            const output = document.getElementById('output');
            output.value = JSON.stringify(allTitles, null, 2);

            // Copy to clipboard
            output.select();
            document.execCommand('copy');

            const status = document.getElementById('status');
            status.textContent = 'Data exported and copied to clipboard!';
        }

        function showSample() {
            generateAllSVGs();
        }

        // Convert SVG to PNG using Canvas
        async function svgToPNG(svgString, width = 200, height = 100) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = width;
                canvas.height = height;

                const img = new Image();
                img.onload = function () {
                    ctx.drawImage(img, 0, 0, width, height);
                    canvas.toBlob(blob => {
                        resolve(blob);
                    }, 'image/png');
                };

                img.onerror = reject;

                // Convert SVG string to data URL
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);
                img.src = url;
            });
        }

        // Download all titles as PNGs in a ZIP file
        async function downloadAllAsPNGs() {
            const status = document.getElementById('status');
            const progress = document.getElementById('progress');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');

            // Generate SVGs if not already done
            if (allTitles.length === 0) {
                generateAllSVGs();
            }

            progress.style.display = 'block';
            status.textContent = 'Converting SVGs to PNGs...';

            try {
                const zip = new JSZip();
                const imagesFolder = zip.folder('title-images');

                let completed = 0;
                const total = allTitles.length;

                for (const title of allTitles) {
                    try {
                        // Extract SVG string from data URL or generate it
                        let svgString;
                        if (title.img && title.img.startsWith('data:image/svg+xml,')) {
                            // Decode from data URL
                            svgString = decodeURIComponent(title.img.replace('data:image/svg+xml,', ''));
                        } else if (title.img && title.img.startsWith('https://')) {
                            // Skip external images
                            completed++;
                            const percent = Math.round((completed / total) * 100);
                            progressFill.style.width = percent + '%';
                            progressText.textContent = `Processed ${completed} of ${total} titles`;
                            continue;
                        } else {
                            // Generate SVG if needed
                            svgString = generator.generateSVG(title);
                        }

                        // Convert to PNG
                        const pngBlob = await svgToPNG(svgString);

                        // Sanitize filename
                        const filename = title.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'untitled';

                        // Add to zip
                        imagesFolder.file(`${filename}.png`, pngBlob);

                        completed++;
                        const percent = Math.round((completed / total) * 100);
                        progressFill.style.width = percent + '%';
                        progressText.textContent = `Processed ${completed} of ${total} titles`;

                    } catch (err) {
                        console.error(`Error processing title ${title.name}:`, err);
                        completed++;
                    }
                }

                status.textContent = 'Creating ZIP file...';
                progressText.textContent = 'Compressing files...';

                // Generate ZIP file
                const content = await zip.generateAsync({ type: 'blob' });

                // Download the ZIP
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = 'title-images.zip';
                link.click();

                status.textContent = 'Download complete!';
                progressText.textContent = 'All titles converted and downloaded successfully!';

                setTimeout(() => {
                    progress.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('Error creating ZIP:', error);
                status.textContent = 'Error: ' + error.message;
                progress.style.display = 'none';
            }
        }

        // Initialize with sample on load
        window.onload = () => {
            showSample();
        };
    </script>
</body>

</html>